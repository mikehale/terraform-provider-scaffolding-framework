// Package main provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	Bearer_tokenScopes = "bearer_token.Scopes"
)

// AccountSchema Account Schema
type AccountSchema struct {
	// BusinessCategoryId business_category_id
	BusinessCategoryId *int64 `json:"business_category_id,omitempty"`

	// BusinessSizeId business_size_id
	BusinessSizeId *int64 `json:"business_size_id,omitempty"`

	// CreatedAt Created at
	CreatedAt *string `json:"created_at,omitempty"`

	// CurrencyId currency_id
	CurrencyId *int64 `json:"currency_id,omitempty"`

	// CustomerId customer_id
	CustomerId *string `json:"customer_id,omitempty"`

	// DomainId domain id
	DomainId *int `json:"domain_id,omitempty"`

	// FrozenAt Frozen at
	FrozenAt *string `json:"frozen_at,omitempty"`

	// Id ID
	Id *int64 `json:"id,omitempty"`

	// IsDisciplinartActionApplicable is_disciplinart_action_applicable
	IsDisciplinartActionApplicable *string `json:"is_disciplinart_action_applicable,omitempty"`

	// IsEnterprise is_enterprise
	IsEnterprise *string `json:"is_enterprise,omitempty"`

	// LowBalanceAt low_balance_at
	LowBalanceAt *string `json:"low_balance_at,omitempty"`

	// ParentAccountId parent_account_id
	ParentAccountId *int `json:"parent_account_id,omitempty"`

	// SuspendedAt Suspended at
	SuspendedAt *string `json:"suspended_at,omitempty"`

	// UpdatedAt Updated at
	UpdatedAt *string `json:"updated_at,omitempty"`

	// Url url
	Url *string `json:"url,omitempty"`

	// Username Account username
	Username *int `json:"username,omitempty"`
}

// AddLoadBalancerRuleRequest Store Load Balancer rule request body
type AddLoadBalancerRuleRequest struct {
	Rules string `json:"rules"`
}

// AsyncJobSchema Async Job Schema
type AsyncJobSchema struct {
	// Original Async Original Job Schema
	Original *OriginalSchema `json:"_original,omitempty"`

	// Id UUID
	Id *int `json:"id,omitempty"`

	// JobId Id of the service
	JobId *string `json:"job_id,omitempty"`
}

// AttachBlockStorageRequest Attach instance to the block storage request body
type AttachBlockStorageRequest struct {
	// Instance Attach instance to the block storage by instance name
	Instance string `json:"instance"`
}

// AttachBlockStorageSchema Attach BlockStorage Schema
type AttachBlockStorageSchema struct {
	// AccountId UUID
	AccountId *int `json:"account_id,omitempty"`

	// CreatedAt Created at
	CreatedAt *string `json:"createdAt,omitempty"`

	// DeletedAt deleted at
	DeletedAt *string `json:"deleted_at,omitempty"`

	// FrozenAt frozen at
	FrozenAt *string `json:"frozen_at,omitempty"`

	// Id UUID
	Id *int `json:"id,omitempty"`

	// InstanceIds UUID
	InstanceIds *int `json:"instance_ids,omitempty"`

	// Name name
	Name *int `json:"name,omitempty"`

	// Project Project Account Schema
	Project *ProjectAccountSchema `json:"project,omitempty"`

	// ProjectId UUID
	ProjectId *int `json:"project_id,omitempty"`

	// Size size
	Size *int `json:"size,omitempty"`

	// SuspendedAt suspended at
	SuspendedAt *string `json:"suspended_at,omitempty"`

	// TerminateAt terminate at
	TerminateAt *string `json:"terminate_at,omitempty"`

	// UpdatedAt updated at
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// BlockStorageResource Block storage resource
type BlockStorageResource struct {
	// Data Data wrapper
	Data *[]BlockStorageSchema `json:"data,omitempty"`
}

// BlockStorageSchema Block storage Schema
type BlockStorageSchema struct {
	// Original Original Object
	Original *string `json:"Original,omitempty"`

	// AccountId Account id of the block storage
	AccountId *string `json:"account_id,omitempty"`

	// CreatedAt Created at
	CreatedAt *string `json:"created_at,omitempty"`

	// DeletedAt Block storage deletion time
	DeletedAt *string `json:"deleted_at,omitempty"`

	// FrozenAt Block storage frozen time
	FrozenAt *string `json:"frozen_at,omitempty"`

	// Id ID
	Id *int `json:"id,omitempty"`

	// Name Name of the block storage
	Name *string `json:"name,omitempty"`

	// Size Size of the block storage
	Size *string `json:"size,omitempty"`

	// SuspendedAt Block storage suspended time
	SuspendedAt *string `json:"suspended_at,omitempty"`

	// TerminatedAt Block storage termination time
	TerminatedAt *string `json:"terminated_at,omitempty"`

	// UpdatedAt Updated at
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// ChangeInstanceHostnameRequest Change instance hostname request body
type ChangeInstanceHostnameRequest struct {
	// Name host name (in url) of the virtual machine
	Name string `json:"name"`
}

// CreateACLListRequest Create ACL List request body
type CreateACLListRequest struct {
	// Description ACL List Description
	Description string `json:"description"`

	// Name ACL List Name
	Name string `json:"name"`
}

// CreateBlockStorageRequest Store block storage request body
type CreateBlockStorageRequest struct {
	// BillingPeriod Billing period for the block storage
	BillingPeriod *string `json:"billing_period,omitempty"`

	// Instance Name of the Instance under the given project
	Instance *string `json:"instance,omitempty"`

	// Name Name of the block storage
	Name string `json:"name"`

	// Package Name of the package with storage size
	Package *string `json:"package,omitempty"`

	// Project Name of the project
	Project *string `json:"project,omitempty"`

	// Zone The name of the zone under which the service should be created.
	Zone *string `json:"zone,omitempty"`
}

// CreateBlockstorageSchema Create Blockstorage Schema
type CreateBlockstorageSchema struct {
	// CancelledAt cancelled at
	CancelledAt *string `json:"cancelledAt,omitempty"`

	// CreatedAt Created at
	CreatedAt  *string `json:"createdAt,omitempty"`
	Failedjobs *string `json:"failedjobs,omitempty"`

	// FinishedAt finished at
	FinishedAt *string `json:"finishedAt,omitempty"`

	// Id UUID
	Id            *int                    `json:"id,omitempty"`
	Name          *string                 `json:"name,omitempty"`
	Options       *map[string]interface{} `json:"options,omitempty"`
	Pendingjobs   *string                 `json:"pendingjobs,omitempty"`
	Processedjobs *string                 `json:"processedjobs,omitempty"`
	Progress      *string                 `json:"progress,omitempty"`
	Totaljobs     *string                 `json:"totaljobs,omitempty"`
}

// CreateEgressRuleRequest Create Egress Rule request body
type CreateEgressRuleRequest struct {
	// CidrList CIDR of a egress rule
	CidrList string `json:"cidr_list"`

	// DestCidrList DIST CIDR
	DestCidrList string `json:"dest_cidr_list"`

	// EndPort end port
	EndPort *string `json:"end_port,omitempty"`

	// IcmpCode icmp_code
	IcmpCode *string `json:"icmp_code,omitempty"`

	// IcmpType icmp_type
	IcmpType *string `json:"icmp_type,omitempty"`

	// Protocol tcp, udp or icmp.
	Protocol string `json:"protocol"`

	// StartPort start port
	StartPort *string `json:"start_port,omitempty"`
}

// CreateFirewallRuleRequest Store Firewall request body
type CreateFirewallRuleRequest struct {
	// Cidr The cidr of the new firewall rule
	Cidr string `json:"cidr"`

	// EndPort The ending port of firewall rule
	EndPort string `json:"end_port"`

	// IcmpCode Error code for this ICMP message
	IcmpCode *string `json:"icmp_code,omitempty"`

	// IcmpType Type of the ICMP message being sent
	IcmpType *string `json:"icmp_type,omitempty"`

	// Ip the IP address of the virtual machine
	Ip string `json:"ip"`

	// Protocol The protocol for the firewall rule. Valid values are tcp , udp and icmp.
	Protocol string `json:"protocol"`

	// StartPort The starting port of firewall rule
	StartPort string `json:"start_port"`
}

// CreateInstanceRequest Store Instance request body
type CreateInstanceRequest struct {
	// BillingPeriod hourly, monthly or yearly
	BillingPeriod string `json:"billing_period"`

	// CouponCode The coupon code
	CouponCode *string `json:"coupon_code,omitempty"`

	// CustomPackage create virtual machine with custom package
	CustomPackage json.RawMessage `json:"custom_package,omitempty"`

	// IsPublicIp create virtual machine with public or private IP. Default true
	IsPublicIp *string `json:"is_public_ip,omitempty"`

	// Keypair SSH key pair
	Keypair *string `json:"keypair,omitempty"`

	// Name host name for the virtual machine
	Name string `json:"name"`

	// Network The name of the network (Isolated/Vpc) under which the service should be created.
	Network string `json:"network"`

	// Package the package name of the service offering for the virtual machine. Mutually Exclusive with custom_package
	Package *string `json:"package,omitempty"`

	// Project The name of the project under which the service should be created.
	Project string `json:"project"`

	// Template the name of the template for the virtual machine. Format os_name/version
	Template string `json:"template"`

	// UserData an optional binary data that can be sent to the virtual machine upon a successful deployment. This binary data must be base64 encoded before adding it to the request. Using HTTP GET (via querystring), you can send up to 4KB of data after base64 encoding. Using HTTP POST(via POST body), you can send up to 1MB of data after base64 encoding.
	UserData *string `json:"user_data,omitempty"`

	// Zone The name of the zone under which the service should be created.
	Zone string `json:"zone"`
}

// CreateIpAddressRequest Create IP Address request body
type CreateIpAddressRequest struct {
	// BillingPeriod billing period
	BillingPeriod string `json:"billing_period"`
}

// CreateKubernetesRequest Store Kubernetes request body
type CreateKubernetesRequest struct {
	// Autoscale whether auto scaling is enabled for the cluster
	Autoscale *string `json:"autoscale,omitempty"`

	// BillingPeriod hourly, monthly or yearly
	BillingPeriod string `json:"billing_period"`

	// ControlNodes number of Kubernetes cluster control nodes, default is 1.
	ControlNodes *string `json:"control_nodes,omitempty"`

	// CouponCode The coupon code
	CouponCode *string `json:"coupon_code,omitempty"`

	// HighAvailability enable/disable high availability by passing control_nodes
	HighAvailability *string `json:"high_availability,omitempty"`

	// KeyPair SSH key pair
	KeyPair *string `json:"key_pair,omitempty"`

	// MaxClusterSize Minimum number of worker nodes in the cluster
	MaxClusterSize *string `json:"max_cluster_size,omitempty"`

	// MinClusterSize Maximum number of worker nodes in the cluster
	MinClusterSize *string `json:"min_cluster_size,omitempty"`

	// Name the name of the template for the cluster
	Name string `json:"name"`

	// NodeSize number of Kubernetes cluster worker nodes
	NodeSize *string `json:"node_size,omitempty"`

	// Package the package name of the service offering for the virtual machine.
	Package string `json:"package"`

	// Project The name of the project under which the service should be created.
	Project string `json:"project"`

	// Version Kubernetes version with which cluster to be launched
	Version string `json:"version"`

	// Zone The name of the zone under which the service should be created.
	Zone string `json:"zone"`
}

// CreateKubernetesSchema Create Kubernetes Schema
type CreateKubernetesSchema struct {
	// AccountId account_id
	AccountId *int64 `json:"account_id,omitempty"`

	// CreatedAt Created at
	CreatedAt *string `json:"created_at,omitempty"`

	// Id ID
	Id *int64 `json:"id,omitempty"`

	// Name kubernetes name
	Name *string `json:"name,omitempty"`

	// ProjectId project id
	ProjectId *int `json:"project_id,omitempty"`

	// UpdatedAt Updated at
	UpdatedAt *string `json:"updated_at,omitempty"`

	// Version kubernetes version
	Version *string `json:"version,omitempty"`
}

// CreateLBRuleSchema Create Load Balancer Rule
type CreateLBRuleSchema struct {
	// Algorithm algorithm
	Algorithm *string `json:"algorithm,omitempty"`

	// CreatedAt Created at
	CreatedAt *string `json:"createdAt,omitempty"`

	// DeletedAt deleted at
	DeletedAt *string `json:"deleted_at,omitempty"`

	// ForceRedirect force_redirect
	ForceRedirect *string `json:"force_redirect,omitempty"`

	// FrozenAt frozen at
	FrozenAt *string `json:"frozen_at,omitempty"`

	// Id UUID
	Id *int `json:"id,omitempty"`

	// InstanceIds UUID
	InstanceIds *int `json:"instance_ids,omitempty"`

	// KeepAlive keep alive
	KeepAlive *string `json:"keep_alive,omitempty"`
	Message   *string `json:"message,omitempty"`

	// Name Load Balancer name
	Name *int `json:"name,omitempty"`

	// Project Project Account Schema
	Project *ProjectAccountSchema `json:"project,omitempty"`

	// ProjectId UUID
	ProjectId *int `json:"project_id,omitempty"`

	// Protocol protocol
	Protocol *string `json:"protocol,omitempty"`

	// StickyMethod sticky method
	StickyMethod *string `json:"sticky_method,omitempty"`

	// SuspendedAt suspended at
	SuspendedAt *string `json:"suspended_at,omitempty"`

	// TerminateAt terminate at
	TerminateAt *string `json:"terminate_at,omitempty"`

	// UpdatedAt updated at
	UpdatedAt *string `json:"updated_at,omitempty"`

	// ZoneId UUID
	ZoneId *int `json:"zone_id,omitempty"`
}

// CreateLoadBalancerRequest Store Network request body
type CreateLoadBalancerRequest struct {
	// Algorithm load balancer algorithm (source, roundrobin, leastconn)
	Algorithm string `json:"algorithm"`

	// BillingPeriod billing_period - hourly, monthly or yearly
	BillingPeriod string `json:"billing_period"`

	// Instance Instance name to be attach to the load balancer
	Instance string `json:"instance"`

	// Name the name of the load balancer
	Name string `json:"name"`

	// Network The name of the network (Isolated/Vpc) under which the service should be created.
	Network string `json:"network"`

	// Project The name of the project under which the service should be created.
	Project string `json:"project"`

	// Protocol The protocol for the LB such as tcp, udp or tcp-proxy.
	Protocol string `json:"protocol"`

	// Rules rules of the load balancer
	Rules string `json:"rules"`

	// Zone The name of the zone under which the service should be created.
	Zone string `json:"zone"`
}

// CreateLoadBalancerRuleSchema Create Load Balancer Rule Schema
type CreateLoadBalancerRuleSchema struct {
	Headers *string `json:"headers,omitempty"`

	// Original Create Load Balancer Rule
	Original *CreateLBRuleSchema `json:"original,omitempty"`
}

// CreateLoadbalancerBatchSchema Create Loadbalancer Schema
type CreateLoadbalancerBatchSchema struct {
	// CancelledAt cancelled at
	CancelledAt *string `json:"cancelledAt,omitempty"`

	// CreatedAt Created at
	CreatedAt  *string `json:"createdAt,omitempty"`
	Failedjobs *string `json:"failedjobs,omitempty"`

	// FinishedAt finished at
	FinishedAt *string `json:"finishedAt,omitempty"`

	// Id UUID
	Id            *int                    `json:"id,omitempty"`
	Name          *string                 `json:"name,omitempty"`
	Options       *map[string]interface{} `json:"options,omitempty"`
	Pendingjobs   *string                 `json:"pendingjobs,omitempty"`
	Processedjobs *string                 `json:"processedjobs,omitempty"`
	Progress      *string                 `json:"progress,omitempty"`
	Totaljobs     *string                 `json:"totaljobs,omitempty"`
}

// CreateLoadbalancerSchema Create Loadbalancer Schema
type CreateLoadbalancerSchema struct {
	// Algorithm algorithm
	Algorithm *string `json:"algorithm,omitempty"`

	// CreatedAt Created at
	CreatedAt *string `json:"createdAt,omitempty"`

	// ForceRedirect force_redirect
	ForceRedirect *string `json:"force_redirect,omitempty"`

	// Id UUID
	Id          *int64                  `json:"id,omitempty"`
	InstanceIds *map[string]interface{} `json:"instance_ids,omitempty"`

	// KeepAlive keep alive
	KeepAlive *string `json:"keep_alive,omitempty"`
	Name      *string `json:"name,omitempty"`

	// Project Project Account Schema
	Project *ProjectAccountSchema `json:"project,omitempty"`

	// ProjectId UUID
	ProjectId *int `json:"project_id,omitempty"`

	// Protocol protocol
	Protocol *string `json:"protocol,omitempty"`

	// StickyMethod sticky method
	StickyMethod *string `json:"sticky_method,omitempty"`

	// UpdatedAt updated at
	UpdatedAt *string `json:"updated_at,omitempty"`

	// ZoneId UUID
	ZoneId *int `json:"zone_id,omitempty"`
}

// CreateNetworkRequest Store Network request body
type CreateNetworkRequest struct {
	// Acl Network ACL associated with the network.
	Acl *string `json:"acl,omitempty"`

	// Description an optional user generated name for the virtual machine
	Description string `json:"description"`

	// ExternalId create virtual machines with public or private IP. Default true
	ExternalId *string `json:"external_id,omitempty"`

	// Gateway the gateway of the network. Required for shared networks and isolated networks when it belongs to VPC
	Gateway *string `json:"gateway,omitempty"`

	// Name host name for the virtual machine
	Name string `json:"name"`

	// Netmask the netmask of the network. Required for shared networks and isolated networks when it belongs to VPC
	Netmask *string `json:"netmask,omitempty"`

	// NetworkOfferingId The network_offering_id
	NetworkOfferingId *string `json:"network_offering_id,omitempty"`

	// Project Project name of the app
	Project string `json:"project"`

	// Vpc the VPC name network belongs to
	Vpc *string `json:"vpc,omitempty"`

	// Zone Availability zone name for the virtual machine
	Zone string `json:"zone"`
}

// CreatePortForwardingRequest Store Port Forwarding request body
type CreatePortForwardingRequest struct {
	// Instance the name of the virtual machine
	Instance string `json:"instance"`

	// Ip the IP address of the virtual machine
	Ip string `json:"ip"`

	// PrivateEndPort The private end port of port forwarding rule’s private port range.
	PrivateEndPort string `json:"private_end_port"`

	// PrivateStartPort The private start port of port forwarding rule’s private port range.
	PrivateStartPort string `json:"private_start_port"`

	// Protocol The protocol for the port forwarding rule. Valid rules are tcp and udp.
	Protocol string `json:"protocol"`

	// PublicEndPort The public end port of port forwarding rule’s public port range.
	PublicEndPort string `json:"public_end_port"`

	// PublicStartPort The public start port of port forwarding rule’s public port range.
	PublicStartPort string `json:"public_start_port"`
}

// CreateProjectRequest Store Project request body
type CreateProjectRequest struct {
	// Description Description of the new project
	Description *string `json:"description,omitempty"`

	// Icon SVG Icon
	Icon *string `json:"icon,omitempty"`

	// Name Name of the new project
	Name string `json:"name"`

	// Purpose Purpose of the project
	Purpose *string `json:"purpose,omitempty"`
}

// CreateScaleClusterRequest Create Scale Cluster request body
type CreateScaleClusterRequest struct {
	// Autoscale Name for the kubernetes scale cluster
	Autoscale string `json:"autoscale"`

	// MaxClusterSize Maximum cluster size of the kubernetes scale cluster
	MaxClusterSize string `json:"max_cluster_size"`

	// MinClusterSize Minimum cluster size of the kubernetes scale cluster
	MinClusterSize string `json:"min_cluster_size"`

	// NodeSize Node size of the kubernetes scale cluster
	NodeSize *string `json:"node_size,omitempty"`

	// Package Name of the package with storage size
	Package string `json:"package"`
}

// CreateSnapshotRequest Create Snapshot request body
type CreateSnapshotRequest struct {
	// Name Name for the Snapshot
	Name string `json:"name"`
}

// CreateVpcRequest Store VPC request body
type CreateVpcRequest struct {
	// BillingPeriod hourly, monthly or yearly
	BillingPeriod string `json:"billing_period"`

	// CouponCode The coupon code
	CouponCode *string `json:"coupon_code,omitempty"`

	// Description an optional user generated name for the virtual machine
	Description string `json:"description"`

	// Name host name for the virtual machine
	Name string `json:"name"`

	// NetworkSize network size (16, 20, 22, 24, 28). Use for cidr parameter
	NetworkSize string `json:"network_size"`

	// Project name of the project
	Project string `json:"project"`

	// RangePrefix Use for cidr parameter
	RangePrefix string `json:"range_prefix"`

	// Zone Availability zone name for the virtual machine
	Zone string `json:"zone"`
}

// DeleteBlockStorageSchema Delete Block Storage Schema
type DeleteBlockStorageSchema struct {
	// CancelledAt cancelled at
	CancelledAt *string `json:"cancelledAt,omitempty"`

	// CreatedAt Created at
	CreatedAt  *string `json:"createdAt,omitempty"`
	Failedjobs *string `json:"failedjobs,omitempty"`

	// FinishedAt finished at
	FinishedAt *string `json:"finishedAt,omitempty"`

	// Id UUID
	Id            *int                    `json:"id,omitempty"`
	Name          *string                 `json:"name,omitempty"`
	Options       *map[string]interface{} `json:"options,omitempty"`
	Pendingjobs   *string                 `json:"pendingjobs,omitempty"`
	Processedjobs *string                 `json:"processedjobs,omitempty"`
	Progress      *string                 `json:"progress,omitempty"`
	Totaljobs     *string                 `json:"totaljobs,omitempty"`
}

// DeleteEgressRuleRequest Delete Egress Rule request body
type DeleteEgressRuleRequest struct {
	// CidrList CIDR of a egress rule
	CidrList string `json:"cidr_list"`

	// EndPort end port
	EndPort *string `json:"end_port,omitempty"`

	// StartPort start port
	StartPort *string `json:"start_port,omitempty"`
}

// DeleteInstanceSchema Delete Instance Schema
type DeleteInstanceSchema struct {
	// CancelledAt cancelled at
	CancelledAt *string `json:"cancelledAt,omitempty"`

	// CreatedAt Created at
	CreatedAt  *string `json:"createdAt,omitempty"`
	Failedjobs *string `json:"failedjobs,omitempty"`

	// FinishedAt finished at
	FinishedAt *string `json:"finishedAt,omitempty"`

	// Id UUID
	Id            *int                    `json:"id,omitempty"`
	Name          *string                 `json:"name,omitempty"`
	Options       *map[string]interface{} `json:"options,omitempty"`
	Pendingjobs   *string                 `json:"pendingjobs,omitempty"`
	Processedjobs *string                 `json:"processedjobs,omitempty"`
	Progress      *string                 `json:"progress,omitempty"`
	Totaljobs     *string                 `json:"totaljobs,omitempty"`
}

// DeleteKubernetesSchema Delete Kubernetes Schema
type DeleteKubernetesSchema struct {
	// CancelledAt cancelled at
	CancelledAt *string `json:"cancelledAt,omitempty"`

	// CreatedAt Created at
	CreatedAt  *string `json:"createdAt,omitempty"`
	Failedjobs *string `json:"failedjobs,omitempty"`

	// FinishedAt finished at
	FinishedAt *string `json:"finishedAt,omitempty"`

	// Id UUID
	Id            *int                    `json:"id,omitempty"`
	Name          *string                 `json:"name,omitempty"`
	Options       *map[string]interface{} `json:"options,omitempty"`
	Pendingjobs   *string                 `json:"pendingjobs,omitempty"`
	Processedjobs *string                 `json:"processedjobs,omitempty"`
	Progress      *string                 `json:"progress,omitempty"`
	Totaljobs     *string                 `json:"totaljobs,omitempty"`
}

// DeleteNetworkSchema Delete Network Schema
type DeleteNetworkSchema struct {
	// CancelledAt cancelled at
	CancelledAt *string `json:"cancelledAt,omitempty"`

	// CreatedAt Created at
	CreatedAt  *string `json:"createdAt,omitempty"`
	Failedjobs *string `json:"failedjobs,omitempty"`

	// FinishedAt finished at
	FinishedAt *string `json:"finishedAt,omitempty"`

	// Id UUID
	Id            *int                    `json:"id,omitempty"`
	Name          *string                 `json:"name,omitempty"`
	Options       *map[string]interface{} `json:"options,omitempty"`
	Pendingjobs   *string                 `json:"pendingjobs,omitempty"`
	Processedjobs *string                 `json:"processedjobs,omitempty"`
	Progress      *string                 `json:"progress,omitempty"`
	Totaljobs     *string                 `json:"totaljobs,omitempty"`
}

// DeleteVpcSchema Delete Vpc Schema
type DeleteVpcSchema struct {
	// CancelledAt cancelled at
	CancelledAt *string `json:"cancelledAt,omitempty"`

	// CreatedAt Created at
	CreatedAt  *string `json:"createdAt,omitempty"`
	Failedjobs *string `json:"failedjobs,omitempty"`

	// FinishedAt finished at
	FinishedAt *string `json:"finishedAt,omitempty"`

	// Id UUID
	Id            *int                    `json:"id,omitempty"`
	Name          *string                 `json:"name,omitempty"`
	Options       *map[string]interface{} `json:"options,omitempty"`
	Pendingjobs   *string                 `json:"pendingjobs,omitempty"`
	Processedjobs *string                 `json:"processedjobs,omitempty"`
	Progress      *string                 `json:"progress,omitempty"`
	Totaljobs     *string                 `json:"totaljobs,omitempty"`
}

// DetachBlockStorageSchema Detach BlockStorage Schema
type DetachBlockStorageSchema struct {
	// AccountId UUID
	AccountId *int `json:"account_id,omitempty"`

	// CreatedAt Created at
	CreatedAt *string `json:"createdAt,omitempty"`

	// DeletedAt deleted at
	DeletedAt *string `json:"deleted_at,omitempty"`

	// FrozenAt frozen at
	FrozenAt *string `json:"frozen_at,omitempty"`

	// Id UUID
	Id *int `json:"id,omitempty"`

	// InstanceIds UUID
	InstanceIds *int `json:"instance_ids,omitempty"`

	// Name name
	Name *int `json:"name,omitempty"`

	// Project Project Account Schema
	Project *ProjectAccountSchema `json:"project,omitempty"`

	// ProjectId UUID
	ProjectId *int `json:"project_id,omitempty"`

	// Size size
	Size *int `json:"size,omitempty"`

	// SuspendedAt suspended at
	SuspendedAt *string `json:"suspended_at,omitempty"`

	// TerminateAt terminate at
	TerminateAt *string `json:"terminate_at,omitempty"`

	// UpdatedAt updated at
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// FirewallResource Firewall resource
type FirewallResource struct {
	// Data Data wrapper
	Data *[]interface{} `json:"data,omitempty"`
}

// InstanceResource Instance resource
type InstanceResource struct {
	// Data Data wrapper
	Data *[]interface{} `json:"data,omitempty"`
}

// InstanceSchema Create Instance Schema
type InstanceSchema struct {
	// CancelledAt cancelled at
	CancelledAt *string `json:"cancelledAt,omitempty"`

	// CreatedAt Created at
	CreatedAt  *string `json:"createdAt,omitempty"`
	Failedjobs *string `json:"failedjobs,omitempty"`

	// FinishedAt finished at
	FinishedAt *string `json:"finishedAt,omitempty"`

	// Id UUID
	Id            *int                    `json:"id,omitempty"`
	Name          *string                 `json:"name,omitempty"`
	Options       *map[string]interface{} `json:"options,omitempty"`
	Pendingjobs   *string                 `json:"pendingjobs,omitempty"`
	Processedjobs *string                 `json:"processedjobs,omitempty"`
	Progress      *string                 `json:"progress,omitempty"`
	Totaljobs     *string                 `json:"totaljobs,omitempty"`
}

// IpAddressStaticNatRequest Ip Address Static Nat Request body
type IpAddressStaticNatRequest struct {
	// Instance Instance Name
	Instance string `json:"instance"`
}

// KubernetesBatchSchema Kubernetes Batch Schema
type KubernetesBatchSchema struct {
	// CancelledAt cancelled at
	CancelledAt *string `json:"cancelledAt,omitempty"`

	// CreatedAt Created at
	CreatedAt  *string `json:"createdAt,omitempty"`
	Failedjobs *string `json:"failedjobs,omitempty"`

	// FinishedAt finished at
	FinishedAt *string `json:"finishedAt,omitempty"`

	// Id UUID
	Id            *int                    `json:"id,omitempty"`
	Name          *string                 `json:"name,omitempty"`
	Options       *map[string]interface{} `json:"options,omitempty"`
	Pendingjobs   *string                 `json:"pendingjobs,omitempty"`
	Processedjobs *string                 `json:"processedjobs,omitempty"`
	Progress      *string                 `json:"progress,omitempty"`
	Totaljobs     *string                 `json:"totaljobs,omitempty"`
}

// KubernetesResource Kubernetes resource
type KubernetesResource struct {
	// Data Data wrapper
	Data *[]interface{} `json:"data,omitempty"`
}

// LoadBalancerResource Load Balancer Resource
type LoadBalancerResource struct {
	// Data Data wrapper
	Data *[]interface{} `json:"data,omitempty"`
}

// NetworkResource Network Resource
type NetworkResource struct {
	// Data Data wrapper
	Data *[]interface{} `json:"data,omitempty"`
}

// NetworkSchema Network Schema
type NetworkSchema struct {
	// AccountId Account Id
	AccountId *int64 `json:"account_id,omitempty"`

	// CreatedAt Created at
	CreatedAt *string `json:"created_at,omitempty"`

	// Default default
	Default *string `json:"default,omitempty"`

	// Description an optional user generated name for the virtual machine
	Description *string `json:"description,omitempty"`

	// Id ID
	Id *int64 `json:"id,omitempty"`

	// Name host name for the virtual machine
	Name *string `json:"name,omitempty"`

	// ParentId Network parent id
	ParentId *string `json:"parent_id,omitempty"`

	// ProjectId Project Id
	ProjectId *string `json:"project_id,omitempty"`

	// Type Network Type
	Type *string `json:"type,omitempty"`

	// UpdatedAt Updated at
	UpdatedAt *string `json:"updated_at,omitempty"`

	// ZoneId Zone Id
	ZoneId *string `json:"zone_id,omitempty"`
}

// OriginalSchema Async Original Job Schema
type OriginalSchema struct {
	// JobId Id of the service
	JobId *string `json:"job_id,omitempty"`
}

// PortForwardingResource Port Forwarding resource
type PortForwardingResource struct {
	// Data Data wrapper
	Data *[]interface{} `json:"data,omitempty"`
}

// ProjectAccountSchema Project Account Schema
type ProjectAccountSchema struct {
	// Account Account Schema
	Account *AccountSchema `json:"account,omitempty"`

	// AccountId Account id of the new project
	AccountId *int `json:"account_id,omitempty"`

	// CreatedAt Created at
	CreatedAt *string `json:"created_at,omitempty"`

	// Description Description of the new project
	Description *string `json:"description,omitempty"`

	// Icon Project icon
	Icon *string `json:"icon,omitempty"`

	// Id ID
	Id *int64 `json:"id,omitempty"`

	// Name Name of the new project
	Name *string `json:"name,omitempty"`

	// Purpose DPurpose project
	Purpose *string `json:"purpose,omitempty"`

	// UpdatedAt Updated at
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// ProjectResource Project resource
type ProjectResource struct {
	// Data Data wrapper
	Data *[]ProjectSchema `json:"data,omitempty"`
}

// ProjectSchema Project Schema
type ProjectSchema struct {
	// AccountId Account id of the new project
	AccountId *int `json:"account_id,omitempty"`

	// CreatedAt Created at
	CreatedAt *string `json:"created_at,omitempty"`

	// Description Description of the new project
	Description *string `json:"description,omitempty"`

	// Icon Project icon
	Icon *string `json:"icon,omitempty"`

	// Id ID
	Id *int64 `json:"id,omitempty"`

	// Name Name of the new project
	Name *string `json:"name,omitempty"`

	// Purpose DPurpose project
	Purpose *string `json:"purpose,omitempty"`

	// UpdatedAt Updated at
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// PublicIpAddressSchema Public IP Address Schema
type PublicIpAddressSchema struct {
	// CancelledAt cancelled at
	CancelledAt *string `json:"cancelledAt,omitempty"`

	// CreatedAt Created at
	CreatedAt  *string `json:"createdAt,omitempty"`
	Failedjobs *string `json:"failedjobs,omitempty"`

	// FinishedAt finished at
	FinishedAt *string `json:"finishedAt,omitempty"`

	// Id UUID
	Id            *int                    `json:"id,omitempty"`
	Name          *string                 `json:"name,omitempty"`
	Options       *map[string]interface{} `json:"options,omitempty"`
	Pendingjobs   *string                 `json:"pendingjobs,omitempty"`
	Processedjobs *string                 `json:"processedjobs,omitempty"`
	Progress      *string                 `json:"progress,omitempty"`
	Totaljobs     *string                 `json:"totaljobs,omitempty"`
}

// RemoveLoadBalancerRuleRequest Store Network request body
type RemoveLoadBalancerRuleRequest struct {
	// PrivatePort the private port of the private IP address/virtual machine where the network traffic will be load balanced to
	PrivatePort string `json:"private_port"`

	// PublicPort the public port from where the network traffic will be load balanced from
	PublicPort string `json:"public_port"`
}

// RemoveLoadBalancerRuleSchema Remove Load Balancer Rule Schema
type RemoveLoadBalancerRuleSchema struct {
	// Exception Exception
	Exception *string `json:"exception,omitempty"`

	// Headers Header
	Headers *string `json:"headers,omitempty"`
}

// SnapshotResource Snapshot Resource
type SnapshotResource struct {
	// Data Data wrapper
	Data *[]interface{} `json:"data,omitempty"`
}

// UpdateLoadBalancerRequest Update Load Balancer request body
type UpdateLoadBalancerRequest struct {
	// PrivatePort the private port of the private IP address/virtual machine where the network traffic will be load balanced to
	PrivatePort string `json:"private_port"`

	// PublicPort the public port from where the network traffic will be load balanced from
	PublicPort string `json:"public_port"`
}

// UpdateProjectRequest Update Project request body
type UpdateProjectRequest struct {
	// Description Description of the new project
	Description *string `json:"description,omitempty"`

	// Icon SVG Icon
	Icon *string `json:"icon,omitempty"`

	// Name Name of the project
	Name string `json:"name"`

	// Purpose Purpose of the project
	Purpose *string `json:"purpose,omitempty"`
}

// UpgradeKubernetesRequest Upgrade Kubernetes Request Body
type UpgradeKubernetesRequest struct {
	// Version the name of the Kubernetes version for upgrade
	Version string `json:"version"`
}

// VpcResource Vpc resource
type VpcResource struct {
	// Data Data wrapper
	Data *[]interface{} `json:"data,omitempty"`
}

// VpcSchema Vpc Schema
type VpcSchema struct {
	// AccountId Account Id
	AccountId *int64 `json:"account_id,omitempty"`

	// CreatedAt Created at
	CreatedAt *string `json:"created_at,omitempty"`

	// Default default
	Default *string `json:"default,omitempty"`

	// Description an optional user generated name for the virtual machine
	Description *string `json:"description,omitempty"`

	// Id ID
	Id *int64 `json:"id,omitempty"`

	// Name host name for the virtual machine
	Name *string `json:"name,omitempty"`

	// ProjectId Project Id
	ProjectId *string `json:"project_id,omitempty"`

	// UpdatedAt Updated at
	UpdatedAt *string `json:"updated_at,omitempty"`

	// ZoneId Zone Id
	ZoneId *string `json:"zone_id,omitempty"`
}

// AttachBlockStorageJSONRequestBody defines body for AttachBlockStorage for application/json ContentType.
type AttachBlockStorageJSONRequestBody = AttachBlockStorageRequest

// StoreBlockStorageJSONRequestBody defines body for StoreBlockStorage for application/json ContentType.
type StoreBlockStorageJSONRequestBody = CreateBlockStorageRequest

// StoreKubernetesJSONRequestBody defines body for StoreKubernetes for application/json ContentType.
type StoreKubernetesJSONRequestBody = CreateKubernetesRequest

// ScaleClusterJSONRequestBody defines body for ScaleCluster for application/json ContentType.
type ScaleClusterJSONRequestBody = CreateScaleClusterRequest

// UpgradeClusterJSONRequestBody defines body for UpgradeCluster for application/json ContentType.
type UpgradeClusterJSONRequestBody = UpgradeKubernetesRequest

// CreateFirewallJSONRequestBody defines body for CreateFirewall for application/json ContentType.
type CreateFirewallJSONRequestBody = CreateFirewallRuleRequest

// ChangeHostnameJSONRequestBody defines body for ChangeHostname for application/json ContentType.
type ChangeHostnameJSONRequestBody = ChangeInstanceHostnameRequest

// StoreInstanceJSONRequestBody defines body for StoreInstance for application/json ContentType.
type StoreInstanceJSONRequestBody = CreateInstanceRequest

// LoadBalanceStoreJSONRequestBody defines body for LoadBalanceStore for application/json ContentType.
type LoadBalanceStoreJSONRequestBody = CreateLoadBalancerRequest

// RemoveRuleJSONRequestBody defines body for RemoveRule for application/json ContentType.
type RemoveRuleJSONRequestBody = RemoveLoadBalancerRuleRequest

// AddRuleJSONRequestBody defines body for AddRule for application/json ContentType.
type AddRuleJSONRequestBody = AddLoadBalancerRuleRequest

// LoadBalacnerUpdateJSONRequestBody defines body for LoadBalacnerUpdate for application/json ContentType.
type LoadBalacnerUpdateJSONRequestBody = UpdateLoadBalancerRequest

// StoreNetworkJSONRequestBody defines body for StoreNetwork for application/json ContentType.
type StoreNetworkJSONRequestBody = CreateNetworkRequest

// DeleteRuleJSONRequestBody defines body for DeleteRule for application/json ContentType.
type DeleteRuleJSONRequestBody = DeleteEgressRuleRequest

// AddEgressRuleJSONRequestBody defines body for AddEgressRule for application/json ContentType.
type AddEgressRuleJSONRequestBody = CreateEgressRuleRequest

// EnableStaticNatJSONRequestBody defines body for EnableStaticNat for application/json ContentType.
type EnableStaticNatJSONRequestBody = IpAddressStaticNatRequest

// AssociateIpAddressJSONRequestBody defines body for AssociateIpAddress for application/json ContentType.
type AssociateIpAddressJSONRequestBody = CreateIpAddressRequest

// CreatePortForwardingJSONRequestBody defines body for CreatePortForwarding for application/json ContentType.
type CreatePortForwardingJSONRequestBody = CreatePortForwardingRequest

// StoreJSONRequestBody defines body for Store for application/json ContentType.
type StoreJSONRequestBody = CreateProjectRequest

// UpdateJSONRequestBody defines body for Update for application/json ContentType.
type UpdateJSONRequestBody = UpdateProjectRequest

// CreateSnapshotJSONRequestBody defines body for CreateSnapshot for application/json ContentType.
type CreateSnapshotJSONRequestBody = CreateSnapshotRequest

// VpcStoreJSONRequestBody defines body for VpcStore for application/json ContentType.
type VpcStoreJSONRequestBody = CreateVpcRequest

// CreateAclJSONRequestBody defines body for CreateAcl for application/json ContentType.
type CreateAclJSONRequestBody = CreateACLListRequest

// UpdateAclListJSONRequestBody defines body for UpdateAclList for application/json ContentType.
type UpdateAclListJSONRequestBody = CreateACLListRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AttachBlockStorageWithBody request with any body
	AttachBlockStorageWithBody(ctx context.Context, blockStorage string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachBlockStorage(ctx context.Context, blockStorage string, body AttachBlockStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreBlockStorageWithBody request with any body
	StoreBlockStorageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreBlockStorage(ctx context.Context, body StoreBlockStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DetachBlockStorage request
	DetachBlockStorage(ctx context.Context, blockStorage string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DestroyBlockStorage request
	DestroyBlockStorage(ctx context.Context, blockStorage string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowBlockStorage request
	ShowBlockStorage(ctx context.Context, blockStorage string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBlockStorage request
	ListBlockStorage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConfigCluster request
	ConfigCluster(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreKubernetesWithBody request with any body
	StoreKubernetesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreKubernetes(ctx context.Context, body StoreKubernetesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScaleClusterWithBody request with any body
	ScaleClusterWithBody(ctx context.Context, kubernetes string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScaleCluster(ctx context.Context, kubernetes string, body ScaleClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopKubernetes request
	StopKubernetes(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpgradeClusterWithBody request with any body
	UpgradeClusterWithBody(ctx context.Context, kubernetes string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpgradeCluster(ctx context.Context, kubernetes string, body UpgradeClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowKubernetes request
	ShowKubernetes(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartKubernetes request
	StartKubernetes(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DestroyKubernetes request
	DestroyKubernetes(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListKubernetes request
	ListKubernetes(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFirewallWithBody request with any body
	CreateFirewallWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFirewall(ctx context.Context, body CreateFirewallJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DestroyFirewall request
	DestroyFirewall(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFirewall request
	ListFirewall(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangeHostnameWithBody request with any body
	ChangeHostnameWithBody(ctx context.Context, instance string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangeHostname(ctx context.Context, instance string, body ChangeHostnameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreInstanceWithBody request with any body
	StoreInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreInstance(ctx context.Context, body StoreInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstancesOfferings request
	InstancesOfferings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Reboot request
	Reboot(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Reinstall request
	Reinstall(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetPassword request
	ResetPassword(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Start request
	Start(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Stop request
	Stop(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstancesTemplate request
	InstancesTemplate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstanceDestroy request
	InstanceDestroy(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstancesShow request
	InstancesShow(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstancesList request
	InstancesList(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadBalanceStoreWithBody request with any body
	LoadBalanceStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LoadBalanceStore(ctx context.Context, body LoadBalanceStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveRuleWithBody request with any body
	RemoveRuleWithBody(ctx context.Context, loadBalancer string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveRule(ctx context.Context, loadBalancer string, body RemoveRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddRuleWithBody request with any body
	AddRuleWithBody(ctx context.Context, loadBalancer string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddRule(ctx context.Context, loadBalancer string, body AddRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DestroyLoadBalancer request
	DestroyLoadBalancer(ctx context.Context, loadBalancer string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadBalancerShow request
	LoadBalancerShow(ctx context.Context, loadBalancer string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadBalacnerUpdateWithBody request with any body
	LoadBalacnerUpdateWithBody(ctx context.Context, loadBalancer string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LoadBalacnerUpdate(ctx context.Context, loadBalancer string, body LoadBalacnerUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadBalancersList request
	LoadBalancersList(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreNetworkWithBody request with any body
	StoreNetworkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StoreNetwork(ctx context.Context, body StoreNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableStaticNat request
	DisableStaticNat(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRuleWithBody request with any body
	DeleteRuleWithBody(ctx context.Context, network string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteRule(ctx context.Context, network string, body DeleteRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddEgressRuleWithBody request with any body
	AddEgressRuleWithBody(ctx context.Context, network string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddEgressRule(ctx context.Context, network string, body AddEgressRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableStaticNatWithBody request with any body
	EnableStaticNatWithBody(ctx context.Context, ipAddress string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnableStaticNat(ctx context.Context, ipAddress string, body EnableStaticNatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisassociateIpAddress request
	DisassociateIpAddress(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssociateIpAddressWithBody request with any body
	AssociateIpAddressWithBody(ctx context.Context, network string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AssociateIpAddress(ctx context.Context, network string, body AssociateIpAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DestroyNetwork request
	DestroyNetwork(ctx context.Context, network string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NetworkShow request
	NetworkShow(ctx context.Context, network string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NetworkList request
	NetworkList(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePortForwardingWithBody request with any body
	CreatePortForwardingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePortForwarding(ctx context.Context, body CreatePortForwardingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DestroyPortForwarding request
	DestroyPortForwarding(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPortForwarding request
	ListPortForwarding(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StoreWithBody request with any body
	StoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Store(ctx context.Context, body StoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWithBody request with any body
	UpdateWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Update(ctx context.Context, project string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjects request
	ListProjects(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSnapshotWithBody request with any body
	CreateSnapshotWithBody(ctx context.Context, blockStorage string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSnapshot(ctx context.Context, blockStorage string, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevertSnapshot request
	RevertSnapshot(ctx context.Context, snapshot string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DestroySnapshot request
	DestroySnapshot(ctx context.Context, snapshot string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowSnapshot request
	ShowSnapshot(ctx context.Context, snapshot string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSnapshot request
	ListSnapshot(ctx context.Context, blockStorage string, project string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAclList request
	ListAclList(ctx context.Context, vpc string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAclList request
	DeleteAclList(ctx context.Context, vpc string, aclName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VpcStoreWithBody request with any body
	VpcStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VpcStore(ctx context.Context, body VpcStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAclList request
	CreateAclList(ctx context.Context, vpc string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAclWithBody request with any body
	CreateAclWithBody(ctx context.Context, vpc string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAcl(ctx context.Context, vpc string, body CreateAclJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAclListWithBody request with any body
	UpdateAclListWithBody(ctx context.Context, vpc string, aclName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAclList(ctx context.Context, vpc string, aclName string, body UpdateAclListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Destroy request
	Destroy(ctx context.Context, vpc string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Show request
	Show(ctx context.Context, vpc string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// List request
	List(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AttachBlockStorageWithBody(ctx context.Context, blockStorage string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachBlockStorageRequestWithBody(c.Server, blockStorage, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachBlockStorage(ctx context.Context, blockStorage string, body AttachBlockStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachBlockStorageRequest(c.Server, blockStorage, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreBlockStorageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreBlockStorageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreBlockStorage(ctx context.Context, body StoreBlockStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreBlockStorageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DetachBlockStorage(ctx context.Context, blockStorage string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDetachBlockStorageRequest(c.Server, blockStorage)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DestroyBlockStorage(ctx context.Context, blockStorage string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDestroyBlockStorageRequest(c.Server, blockStorage)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowBlockStorage(ctx context.Context, blockStorage string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowBlockStorageRequest(c.Server, blockStorage)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBlockStorage(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBlockStorageRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConfigCluster(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConfigClusterRequest(c.Server, kubernetes)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreKubernetesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreKubernetesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreKubernetes(ctx context.Context, body StoreKubernetesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreKubernetesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScaleClusterWithBody(ctx context.Context, kubernetes string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScaleClusterRequestWithBody(c.Server, kubernetes, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScaleCluster(ctx context.Context, kubernetes string, body ScaleClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScaleClusterRequest(c.Server, kubernetes, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopKubernetes(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopKubernetesRequest(c.Server, kubernetes)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpgradeClusterWithBody(ctx context.Context, kubernetes string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpgradeClusterRequestWithBody(c.Server, kubernetes, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpgradeCluster(ctx context.Context, kubernetes string, body UpgradeClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpgradeClusterRequest(c.Server, kubernetes, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowKubernetes(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowKubernetesRequest(c.Server, kubernetes)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartKubernetes(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartKubernetesRequest(c.Server, kubernetes)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DestroyKubernetes(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDestroyKubernetesRequest(c.Server, kubernetes)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListKubernetes(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListKubernetesRequest(c.Server, project)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFirewallWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFirewallRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFirewall(ctx context.Context, body CreateFirewallJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFirewallRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DestroyFirewall(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDestroyFirewallRequest(c.Server, ipAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFirewall(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFirewallRequest(c.Server, ipAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeHostnameWithBody(ctx context.Context, instance string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeHostnameRequestWithBody(c.Server, instance, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangeHostname(ctx context.Context, instance string, body ChangeHostnameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangeHostnameRequest(c.Server, instance, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreInstanceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreInstanceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreInstance(ctx context.Context, body StoreInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreInstanceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstancesOfferings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstancesOfferingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Reboot(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRebootRequest(c.Server, instance)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Reinstall(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReinstallRequest(c.Server, instance)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPassword(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequest(c.Server, instance)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Start(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartRequest(c.Server, instance)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Stop(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopRequest(c.Server, instance)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstancesTemplate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstancesTemplateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstanceDestroy(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstanceDestroyRequest(c.Server, instance)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstancesShow(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstancesShowRequest(c.Server, instance)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstancesList(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstancesListRequest(c.Server, project)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadBalanceStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadBalanceStoreRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadBalanceStore(ctx context.Context, body LoadBalanceStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadBalanceStoreRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRuleWithBody(ctx context.Context, loadBalancer string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRuleRequestWithBody(c.Server, loadBalancer, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveRule(ctx context.Context, loadBalancer string, body RemoveRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveRuleRequest(c.Server, loadBalancer, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRuleWithBody(ctx context.Context, loadBalancer string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRuleRequestWithBody(c.Server, loadBalancer, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRule(ctx context.Context, loadBalancer string, body AddRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRuleRequest(c.Server, loadBalancer, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DestroyLoadBalancer(ctx context.Context, loadBalancer string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDestroyLoadBalancerRequest(c.Server, loadBalancer)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadBalancerShow(ctx context.Context, loadBalancer string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadBalancerShowRequest(c.Server, loadBalancer)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadBalacnerUpdateWithBody(ctx context.Context, loadBalancer string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadBalacnerUpdateRequestWithBody(c.Server, loadBalancer, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadBalacnerUpdate(ctx context.Context, loadBalancer string, body LoadBalacnerUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadBalacnerUpdateRequest(c.Server, loadBalancer, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadBalancersList(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadBalancersListRequest(c.Server, project)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreNetworkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreNetworkRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreNetwork(ctx context.Context, body StoreNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreNetworkRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableStaticNat(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableStaticNatRequest(c.Server, ipAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRuleWithBody(ctx context.Context, network string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuleRequestWithBody(c.Server, network, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRule(ctx context.Context, network string, body DeleteRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuleRequest(c.Server, network, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddEgressRuleWithBody(ctx context.Context, network string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddEgressRuleRequestWithBody(c.Server, network, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddEgressRule(ctx context.Context, network string, body AddEgressRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddEgressRuleRequest(c.Server, network, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableStaticNatWithBody(ctx context.Context, ipAddress string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableStaticNatRequestWithBody(c.Server, ipAddress, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableStaticNat(ctx context.Context, ipAddress string, body EnableStaticNatJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableStaticNatRequest(c.Server, ipAddress, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisassociateIpAddress(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisassociateIpAddressRequest(c.Server, ipAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssociateIpAddressWithBody(ctx context.Context, network string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssociateIpAddressRequestWithBody(c.Server, network, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssociateIpAddress(ctx context.Context, network string, body AssociateIpAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssociateIpAddressRequest(c.Server, network, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DestroyNetwork(ctx context.Context, network string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDestroyNetworkRequest(c.Server, network)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NetworkShow(ctx context.Context, network string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworkShowRequest(c.Server, network)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NetworkList(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNetworkListRequest(c.Server, project)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePortForwardingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePortForwardingRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePortForwarding(ctx context.Context, body CreatePortForwardingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePortForwardingRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DestroyPortForwarding(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDestroyPortForwardingRequest(c.Server, ipAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPortForwarding(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPortForwardingRequest(c.Server, ipAddress)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Store(ctx context.Context, body StoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStoreRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequestWithBody(c.Server, project, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Update(ctx context.Context, project string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequest(c.Server, project, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjects(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSnapshotWithBody(ctx context.Context, blockStorage string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSnapshotRequestWithBody(c.Server, blockStorage, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSnapshot(ctx context.Context, blockStorage string, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSnapshotRequest(c.Server, blockStorage, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevertSnapshot(ctx context.Context, snapshot string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevertSnapshotRequest(c.Server, snapshot)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DestroySnapshot(ctx context.Context, snapshot string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDestroySnapshotRequest(c.Server, snapshot)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowSnapshot(ctx context.Context, snapshot string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowSnapshotRequest(c.Server, snapshot)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSnapshot(ctx context.Context, blockStorage string, project string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSnapshotRequest(c.Server, blockStorage, project)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAclList(ctx context.Context, vpc string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAclListRequest(c.Server, vpc)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAclList(ctx context.Context, vpc string, aclName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAclListRequest(c.Server, vpc, aclName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VpcStoreWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVpcStoreRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VpcStore(ctx context.Context, body VpcStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVpcStoreRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclList(ctx context.Context, vpc string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclListRequest(c.Server, vpc)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclWithBody(ctx context.Context, vpc string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclRequestWithBody(c.Server, vpc, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAcl(ctx context.Context, vpc string, body CreateAclJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclRequest(c.Server, vpc, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAclListWithBody(ctx context.Context, vpc string, aclName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAclListRequestWithBody(c.Server, vpc, aclName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAclList(ctx context.Context, vpc string, aclName string, body UpdateAclListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAclListRequest(c.Server, vpc, aclName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Destroy(ctx context.Context, vpc string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDestroyRequest(c.Server, vpc)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Show(ctx context.Context, vpc string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowRequest(c.Server, vpc)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) List(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRequest(c.Server, project)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAttachBlockStorageRequest calls the generic AttachBlockStorage builder with application/json body
func NewAttachBlockStorageRequest(server string, blockStorage string, body AttachBlockStorageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachBlockStorageRequestWithBody(server, blockStorage, "application/json", bodyReader)
}

// NewAttachBlockStorageRequestWithBody generates requests for AttachBlockStorage with any type of body
func NewAttachBlockStorageRequestWithBody(server string, blockStorage string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "block_storage", runtime.ParamLocationPath, blockStorage)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/block-storage/attach/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStoreBlockStorageRequest calls the generic StoreBlockStorage builder with application/json body
func NewStoreBlockStorageRequest(server string, body StoreBlockStorageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreBlockStorageRequestWithBody(server, "application/json", bodyReader)
}

// NewStoreBlockStorageRequestWithBody generates requests for StoreBlockStorage with any type of body
func NewStoreBlockStorageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/block-storage/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDetachBlockStorageRequest generates requests for DetachBlockStorage
func NewDetachBlockStorageRequest(server string, blockStorage string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "block_storage", runtime.ParamLocationPath, blockStorage)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/block-storage/detach/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDestroyBlockStorageRequest generates requests for DestroyBlockStorage
func NewDestroyBlockStorageRequest(server string, blockStorage string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "block_storage", runtime.ParamLocationPath, blockStorage)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/block-storage/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowBlockStorageRequest generates requests for ShowBlockStorage
func NewShowBlockStorageRequest(server string, blockStorage string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "block_storage", runtime.ParamLocationPath, blockStorage)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/block-storage/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBlockStorageRequest generates requests for ListBlockStorage
func NewListBlockStorageRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/block-storages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConfigClusterRequest generates requests for ConfigCluster
func NewConfigClusterRequest(server string, kubernetes string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "kubernetes", runtime.ParamLocationPath, kubernetes)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster/config/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreKubernetesRequest calls the generic StoreKubernetes builder with application/json body
func NewStoreKubernetesRequest(server string, body StoreKubernetesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreKubernetesRequestWithBody(server, "application/json", bodyReader)
}

// NewStoreKubernetesRequestWithBody generates requests for StoreKubernetes with any type of body
func NewStoreKubernetesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScaleClusterRequest calls the generic ScaleCluster builder with application/json body
func NewScaleClusterRequest(server string, kubernetes string, body ScaleClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScaleClusterRequestWithBody(server, kubernetes, "application/json", bodyReader)
}

// NewScaleClusterRequestWithBody generates requests for ScaleCluster with any type of body
func NewScaleClusterRequestWithBody(server string, kubernetes string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "kubernetes", runtime.ParamLocationPath, kubernetes)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster/scale/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStopKubernetesRequest generates requests for StopKubernetes
func NewStopKubernetesRequest(server string, kubernetes string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "kubernetes", runtime.ParamLocationPath, kubernetes)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster/stop/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpgradeClusterRequest calls the generic UpgradeCluster builder with application/json body
func NewUpgradeClusterRequest(server string, kubernetes string, body UpgradeClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpgradeClusterRequestWithBody(server, kubernetes, "application/json", bodyReader)
}

// NewUpgradeClusterRequestWithBody generates requests for UpgradeCluster with any type of body
func NewUpgradeClusterRequestWithBody(server string, kubernetes string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "kubernetes", runtime.ParamLocationPath, kubernetes)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster/upgrade/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewShowKubernetesRequest generates requests for ShowKubernetes
func NewShowKubernetesRequest(server string, kubernetes string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "kubernetes", runtime.ParamLocationPath, kubernetes)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartKubernetesRequest generates requests for StartKubernetes
func NewStartKubernetesRequest(server string, kubernetes string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "kubernetes", runtime.ParamLocationPath, kubernetes)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/start/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDestroyKubernetesRequest generates requests for DestroyKubernetes
func NewDestroyKubernetesRequest(server string, kubernetes string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "kubernetes", runtime.ParamLocationPath, kubernetes)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListKubernetesRequest generates requests for ListKubernetes
func NewListKubernetesRequest(server string, project string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFirewallRequest calls the generic CreateFirewall builder with application/json body
func NewCreateFirewallRequest(server string, body CreateFirewallJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFirewallRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFirewallRequestWithBody generates requests for CreateFirewall with any type of body
func NewCreateFirewallRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/firewalls")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDestroyFirewallRequest generates requests for DestroyFirewall
func NewDestroyFirewallRequest(server string, ipAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ip_address", runtime.ParamLocationPath, ipAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/firewalls/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFirewallRequest generates requests for ListFirewall
func NewListFirewallRequest(server string, ipAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ip_address", runtime.ParamLocationPath, ipAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/firewalls/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChangeHostnameRequest calls the generic ChangeHostname builder with application/json body
func NewChangeHostnameRequest(server string, instance string, body ChangeHostnameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangeHostnameRequestWithBody(server, instance, "application/json", bodyReader)
}

// NewChangeHostnameRequestWithBody generates requests for ChangeHostname with any type of body
func NewChangeHostnameRequestWithBody(server string, instance string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "instance", runtime.ParamLocationPath, instance)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/instance/change-hostname/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStoreInstanceRequest calls the generic StoreInstance builder with application/json body
func NewStoreInstanceRequest(server string, body StoreInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreInstanceRequestWithBody(server, "application/json", bodyReader)
}

// NewStoreInstanceRequestWithBody generates requests for StoreInstance with any type of body
func NewStoreInstanceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/instance/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInstancesOfferingsRequest generates requests for InstancesOfferings
func NewInstancesOfferingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/instance/offerings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRebootRequest generates requests for Reboot
func NewRebootRequest(server string, instance string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "instance", runtime.ParamLocationPath, instance)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/instance/reboot/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReinstallRequest generates requests for Reinstall
func NewReinstallRequest(server string, instance string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "instance", runtime.ParamLocationPath, instance)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/instance/reinstall/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetPasswordRequest generates requests for ResetPassword
func NewResetPasswordRequest(server string, instance string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "instance", runtime.ParamLocationPath, instance)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/instance/reset-password/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartRequest generates requests for Start
func NewStartRequest(server string, instance string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "instance", runtime.ParamLocationPath, instance)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/instance/start/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopRequest generates requests for Stop
func NewStopRequest(server string, instance string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "instance", runtime.ParamLocationPath, instance)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/instance/stop/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstancesTemplateRequest generates requests for InstancesTemplate
func NewInstancesTemplateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/instance/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstanceDestroyRequest generates requests for InstanceDestroy
func NewInstanceDestroyRequest(server string, instance string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "instance", runtime.ParamLocationPath, instance)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/instance/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstancesShowRequest generates requests for InstancesShow
func NewInstancesShowRequest(server string, instance string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "instance", runtime.ParamLocationPath, instance)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/instance/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstancesListRequest generates requests for InstancesList
func NewInstancesListRequest(server string, project string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadBalanceStoreRequest calls the generic LoadBalanceStore builder with application/json body
func NewLoadBalanceStoreRequest(server string, body LoadBalanceStoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoadBalanceStoreRequestWithBody(server, "application/json", bodyReader)
}

// NewLoadBalanceStoreRequestWithBody generates requests for LoadBalanceStore with any type of body
func NewLoadBalanceStoreRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/load-balancer/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveRuleRequest calls the generic RemoveRule builder with application/json body
func NewRemoveRuleRequest(server string, loadBalancer string, body RemoveRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveRuleRequestWithBody(server, loadBalancer, "application/json", bodyReader)
}

// NewRemoveRuleRequestWithBody generates requests for RemoveRule with any type of body
func NewRemoveRuleRequestWithBody(server string, loadBalancer string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "load_balancer", runtime.ParamLocationPath, loadBalancer)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/load-balancer/rule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddRuleRequest calls the generic AddRule builder with application/json body
func NewAddRuleRequest(server string, loadBalancer string, body AddRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddRuleRequestWithBody(server, loadBalancer, "application/json", bodyReader)
}

// NewAddRuleRequestWithBody generates requests for AddRule with any type of body
func NewAddRuleRequestWithBody(server string, loadBalancer string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "load_balancer", runtime.ParamLocationPath, loadBalancer)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/load-balancer/rule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDestroyLoadBalancerRequest generates requests for DestroyLoadBalancer
func NewDestroyLoadBalancerRequest(server string, loadBalancer string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "load_balancer", runtime.ParamLocationPath, loadBalancer)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/load-balancers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadBalancerShowRequest generates requests for LoadBalancerShow
func NewLoadBalancerShowRequest(server string, loadBalancer string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "load_balancer", runtime.ParamLocationPath, loadBalancer)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/load-balancers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoadBalacnerUpdateRequest calls the generic LoadBalacnerUpdate builder with application/json body
func NewLoadBalacnerUpdateRequest(server string, loadBalancer string, body LoadBalacnerUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoadBalacnerUpdateRequestWithBody(server, loadBalancer, "application/json", bodyReader)
}

// NewLoadBalacnerUpdateRequestWithBody generates requests for LoadBalacnerUpdate with any type of body
func NewLoadBalacnerUpdateRequestWithBody(server string, loadBalancer string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "load_balancer", runtime.ParamLocationPath, loadBalancer)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/load-balancers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLoadBalancersListRequest generates requests for LoadBalancersList
func NewLoadBalancersListRequest(server string, project string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/load-balancers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreNetworkRequest calls the generic StoreNetwork builder with application/json body
func NewStoreNetworkRequest(server string, body StoreNetworkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreNetworkRequestWithBody(server, "application/json", bodyReader)
}

// NewStoreNetworkRequestWithBody generates requests for StoreNetwork with any type of body
func NewStoreNetworkRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/network/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDisableStaticNatRequest generates requests for DisableStaticNat
func NewDisableStaticNatRequest(server string, ipAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ip_address", runtime.ParamLocationPath, ipAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/network/disable-static-nat/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRuleRequest calls the generic DeleteRule builder with application/json body
func NewDeleteRuleRequest(server string, network string, body DeleteRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteRuleRequestWithBody(server, network, "application/json", bodyReader)
}

// NewDeleteRuleRequestWithBody generates requests for DeleteRule with any type of body
func NewDeleteRuleRequestWithBody(server string, network string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network", runtime.ParamLocationPath, network)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/network/egress_rule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddEgressRuleRequest calls the generic AddEgressRule builder with application/json body
func NewAddEgressRuleRequest(server string, network string, body AddEgressRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddEgressRuleRequestWithBody(server, network, "application/json", bodyReader)
}

// NewAddEgressRuleRequestWithBody generates requests for AddEgressRule with any type of body
func NewAddEgressRuleRequestWithBody(server string, network string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network", runtime.ParamLocationPath, network)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/network/egress_rule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnableStaticNatRequest calls the generic EnableStaticNat builder with application/json body
func NewEnableStaticNatRequest(server string, ipAddress string, body EnableStaticNatJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnableStaticNatRequestWithBody(server, ipAddress, "application/json", bodyReader)
}

// NewEnableStaticNatRequestWithBody generates requests for EnableStaticNat with any type of body
func NewEnableStaticNatRequestWithBody(server string, ipAddress string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ip_address", runtime.ParamLocationPath, ipAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/network/enable-static-nat/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDisassociateIpAddressRequest generates requests for DisassociateIpAddress
func NewDisassociateIpAddressRequest(server string, ipAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ip_address", runtime.ParamLocationPath, ipAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/network/ip-address/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssociateIpAddressRequest calls the generic AssociateIpAddress builder with application/json body
func NewAssociateIpAddressRequest(server string, network string, body AssociateIpAddressJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAssociateIpAddressRequestWithBody(server, network, "application/json", bodyReader)
}

// NewAssociateIpAddressRequestWithBody generates requests for AssociateIpAddress with any type of body
func NewAssociateIpAddressRequestWithBody(server string, network string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network", runtime.ParamLocationPath, network)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/network/ip-address/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDestroyNetworkRequest generates requests for DestroyNetwork
func NewDestroyNetworkRequest(server string, network string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network", runtime.ParamLocationPath, network)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/network/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNetworkShowRequest generates requests for NetworkShow
func NewNetworkShowRequest(server string, network string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "network", runtime.ParamLocationPath, network)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/network/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNetworkListRequest generates requests for NetworkList
func NewNetworkListRequest(server string, project string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/networks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePortForwardingRequest calls the generic CreatePortForwarding builder with application/json body
func NewCreatePortForwardingRequest(server string, body CreatePortForwardingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePortForwardingRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePortForwardingRequestWithBody generates requests for CreatePortForwarding with any type of body
func NewCreatePortForwardingRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/port-forwarding")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDestroyPortForwardingRequest generates requests for DestroyPortForwarding
func NewDestroyPortForwardingRequest(server string, ipAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ip_address", runtime.ParamLocationPath, ipAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/port-forwarding/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPortForwardingRequest generates requests for ListPortForwarding
func NewListPortForwardingRequest(server string, ipAddress string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ip_address", runtime.ParamLocationPath, ipAddress)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/port-forwarding/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStoreRequest calls the generic Store builder with application/json body
func NewStoreRequest(server string, body StoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStoreRequestWithBody(server, "application/json", bodyReader)
}

// NewStoreRequestWithBody generates requests for Store with any type of body
func NewStoreRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/project/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateRequest calls the generic Update builder with application/json body
func NewUpdateRequest(server string, project string, body UpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRequestWithBody(server, project, "application/json", bodyReader)
}

// NewUpdateRequestWithBody generates requests for Update with any type of body
func NewUpdateRequestWithBody(server string, project string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/project/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProjectsRequest generates requests for ListProjects
func NewListProjectsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSnapshotRequest calls the generic CreateSnapshot builder with application/json body
func NewCreateSnapshotRequest(server string, blockStorage string, body CreateSnapshotJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSnapshotRequestWithBody(server, blockStorage, "application/json", bodyReader)
}

// NewCreateSnapshotRequestWithBody generates requests for CreateSnapshot with any type of body
func NewCreateSnapshotRequestWithBody(server string, blockStorage string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "block_storage", runtime.ParamLocationPath, blockStorage)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snapshot/create/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevertSnapshotRequest generates requests for RevertSnapshot
func NewRevertSnapshotRequest(server string, snapshot string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "snapshot", runtime.ParamLocationPath, snapshot)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snapshot/revert/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDestroySnapshotRequest generates requests for DestroySnapshot
func NewDestroySnapshotRequest(server string, snapshot string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "snapshot", runtime.ParamLocationPath, snapshot)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snapshot/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowSnapshotRequest generates requests for ShowSnapshot
func NewShowSnapshotRequest(server string, snapshot string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "snapshot", runtime.ParamLocationPath, snapshot)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snapshot/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSnapshotRequest generates requests for ListSnapshot
func NewListSnapshotRequest(server string, blockStorage string, project string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "block_storage", runtime.ParamLocationPath, blockStorage)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/snapshots/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAclListRequest generates requests for ListAclList
func NewListAclListRequest(server string, vpc string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vpc", runtime.ParamLocationPath, vpc)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vpc/acl_list/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAclListRequest generates requests for DeleteAclList
func NewDeleteAclListRequest(server string, vpc string, aclName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vpc", runtime.ParamLocationPath, vpc)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "acl_name", runtime.ParamLocationPath, aclName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vpc/acl_list/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVpcStoreRequest calls the generic VpcStore builder with application/json body
func NewVpcStoreRequest(server string, body VpcStoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVpcStoreRequestWithBody(server, "application/json", bodyReader)
}

// NewVpcStoreRequestWithBody generates requests for VpcStore with any type of body
func NewVpcStoreRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vpc/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAclListRequest generates requests for CreateAclList
func NewCreateAclListRequest(server string, vpc string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vpc", runtime.ParamLocationPath, vpc)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vpc/create/acl_list/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAclRequest calls the generic CreateAcl builder with application/json body
func NewCreateAclRequest(server string, vpc string, body CreateAclJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAclRequestWithBody(server, vpc, "application/json", bodyReader)
}

// NewCreateAclRequestWithBody generates requests for CreateAcl with any type of body
func NewCreateAclRequestWithBody(server string, vpc string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vpc", runtime.ParamLocationPath, vpc)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vpc/create/acl_rule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateAclListRequest calls the generic UpdateAclList builder with application/json body
func NewUpdateAclListRequest(server string, vpc string, aclName string, body UpdateAclListJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAclListRequestWithBody(server, vpc, aclName, "application/json", bodyReader)
}

// NewUpdateAclListRequestWithBody generates requests for UpdateAclList with any type of body
func NewUpdateAclListRequestWithBody(server string, vpc string, aclName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vpc", runtime.ParamLocationPath, vpc)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "acl_name", runtime.ParamLocationPath, aclName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vpc/update/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDestroyRequest generates requests for Destroy
func NewDestroyRequest(server string, vpc string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vpc", runtime.ParamLocationPath, vpc)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vpc/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowRequest generates requests for Show
func NewShowRequest(server string, vpc string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "vpc", runtime.ParamLocationPath, vpc)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vpc/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRequest generates requests for List
func NewListRequest(server string, project string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vpcs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AttachBlockStorageWithBodyWithResponse request with any body
	AttachBlockStorageWithBodyWithResponse(ctx context.Context, blockStorage string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachBlockStorageResponse, error)

	AttachBlockStorageWithResponse(ctx context.Context, blockStorage string, body AttachBlockStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachBlockStorageResponse, error)

	// StoreBlockStorageWithBodyWithResponse request with any body
	StoreBlockStorageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreBlockStorageResponse, error)

	StoreBlockStorageWithResponse(ctx context.Context, body StoreBlockStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreBlockStorageResponse, error)

	// DetachBlockStorageWithResponse request
	DetachBlockStorageWithResponse(ctx context.Context, blockStorage string, reqEditors ...RequestEditorFn) (*DetachBlockStorageResponse, error)

	// DestroyBlockStorageWithResponse request
	DestroyBlockStorageWithResponse(ctx context.Context, blockStorage string, reqEditors ...RequestEditorFn) (*DestroyBlockStorageResponse, error)

	// ShowBlockStorageWithResponse request
	ShowBlockStorageWithResponse(ctx context.Context, blockStorage string, reqEditors ...RequestEditorFn) (*ShowBlockStorageResponse, error)

	// ListBlockStorageWithResponse request
	ListBlockStorageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListBlockStorageResponse, error)

	// ConfigClusterWithResponse request
	ConfigClusterWithResponse(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*ConfigClusterResponse, error)

	// StoreKubernetesWithBodyWithResponse request with any body
	StoreKubernetesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreKubernetesResponse, error)

	StoreKubernetesWithResponse(ctx context.Context, body StoreKubernetesJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreKubernetesResponse, error)

	// ScaleClusterWithBodyWithResponse request with any body
	ScaleClusterWithBodyWithResponse(ctx context.Context, kubernetes string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScaleClusterResponse, error)

	ScaleClusterWithResponse(ctx context.Context, kubernetes string, body ScaleClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*ScaleClusterResponse, error)

	// StopKubernetesWithResponse request
	StopKubernetesWithResponse(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*StopKubernetesResponse, error)

	// UpgradeClusterWithBodyWithResponse request with any body
	UpgradeClusterWithBodyWithResponse(ctx context.Context, kubernetes string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpgradeClusterResponse, error)

	UpgradeClusterWithResponse(ctx context.Context, kubernetes string, body UpgradeClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpgradeClusterResponse, error)

	// ShowKubernetesWithResponse request
	ShowKubernetesWithResponse(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*ShowKubernetesResponse, error)

	// StartKubernetesWithResponse request
	StartKubernetesWithResponse(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*StartKubernetesResponse, error)

	// DestroyKubernetesWithResponse request
	DestroyKubernetesWithResponse(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*DestroyKubernetesResponse, error)

	// ListKubernetesWithResponse request
	ListKubernetesWithResponse(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*ListKubernetesResponse, error)

	// CreateFirewallWithBodyWithResponse request with any body
	CreateFirewallWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFirewallResponse, error)

	CreateFirewallWithResponse(ctx context.Context, body CreateFirewallJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFirewallResponse, error)

	// DestroyFirewallWithResponse request
	DestroyFirewallWithResponse(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*DestroyFirewallResponse, error)

	// ListFirewallWithResponse request
	ListFirewallWithResponse(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*ListFirewallResponse, error)

	// ChangeHostnameWithBodyWithResponse request with any body
	ChangeHostnameWithBodyWithResponse(ctx context.Context, instance string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeHostnameResponse, error)

	ChangeHostnameWithResponse(ctx context.Context, instance string, body ChangeHostnameJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeHostnameResponse, error)

	// StoreInstanceWithBodyWithResponse request with any body
	StoreInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreInstanceResponse, error)

	StoreInstanceWithResponse(ctx context.Context, body StoreInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreInstanceResponse, error)

	// InstancesOfferingsWithResponse request
	InstancesOfferingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InstancesOfferingsResponse, error)

	// RebootWithResponse request
	RebootWithResponse(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*RebootResponse, error)

	// ReinstallWithResponse request
	ReinstallWithResponse(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*ReinstallResponse, error)

	// ResetPasswordWithResponse request
	ResetPasswordWithResponse(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	// StartWithResponse request
	StartWithResponse(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*StartResponse, error)

	// StopWithResponse request
	StopWithResponse(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*StopResponse, error)

	// InstancesTemplateWithResponse request
	InstancesTemplateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InstancesTemplateResponse, error)

	// InstanceDestroyWithResponse request
	InstanceDestroyWithResponse(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*InstanceDestroyResponse, error)

	// InstancesShowWithResponse request
	InstancesShowWithResponse(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*InstancesShowResponse, error)

	// InstancesListWithResponse request
	InstancesListWithResponse(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*InstancesListResponse, error)

	// LoadBalanceStoreWithBodyWithResponse request with any body
	LoadBalanceStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoadBalanceStoreResponse, error)

	LoadBalanceStoreWithResponse(ctx context.Context, body LoadBalanceStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*LoadBalanceStoreResponse, error)

	// RemoveRuleWithBodyWithResponse request with any body
	RemoveRuleWithBodyWithResponse(ctx context.Context, loadBalancer string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveRuleResponse, error)

	RemoveRuleWithResponse(ctx context.Context, loadBalancer string, body RemoveRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveRuleResponse, error)

	// AddRuleWithBodyWithResponse request with any body
	AddRuleWithBodyWithResponse(ctx context.Context, loadBalancer string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRuleResponse, error)

	AddRuleWithResponse(ctx context.Context, loadBalancer string, body AddRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRuleResponse, error)

	// DestroyLoadBalancerWithResponse request
	DestroyLoadBalancerWithResponse(ctx context.Context, loadBalancer string, reqEditors ...RequestEditorFn) (*DestroyLoadBalancerResponse, error)

	// LoadBalancerShowWithResponse request
	LoadBalancerShowWithResponse(ctx context.Context, loadBalancer string, reqEditors ...RequestEditorFn) (*LoadBalancerShowResponse, error)

	// LoadBalacnerUpdateWithBodyWithResponse request with any body
	LoadBalacnerUpdateWithBodyWithResponse(ctx context.Context, loadBalancer string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoadBalacnerUpdateResponse, error)

	LoadBalacnerUpdateWithResponse(ctx context.Context, loadBalancer string, body LoadBalacnerUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*LoadBalacnerUpdateResponse, error)

	// LoadBalancersListWithResponse request
	LoadBalancersListWithResponse(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*LoadBalancersListResponse, error)

	// StoreNetworkWithBodyWithResponse request with any body
	StoreNetworkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreNetworkResponse, error)

	StoreNetworkWithResponse(ctx context.Context, body StoreNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreNetworkResponse, error)

	// DisableStaticNatWithResponse request
	DisableStaticNatWithResponse(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*DisableStaticNatResponse, error)

	// DeleteRuleWithBodyWithResponse request with any body
	DeleteRuleWithBodyWithResponse(ctx context.Context, network string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error)

	DeleteRuleWithResponse(ctx context.Context, network string, body DeleteRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error)

	// AddEgressRuleWithBodyWithResponse request with any body
	AddEgressRuleWithBodyWithResponse(ctx context.Context, network string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddEgressRuleResponse, error)

	AddEgressRuleWithResponse(ctx context.Context, network string, body AddEgressRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddEgressRuleResponse, error)

	// EnableStaticNatWithBodyWithResponse request with any body
	EnableStaticNatWithBodyWithResponse(ctx context.Context, ipAddress string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableStaticNatResponse, error)

	EnableStaticNatWithResponse(ctx context.Context, ipAddress string, body EnableStaticNatJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableStaticNatResponse, error)

	// DisassociateIpAddressWithResponse request
	DisassociateIpAddressWithResponse(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*DisassociateIpAddressResponse, error)

	// AssociateIpAddressWithBodyWithResponse request with any body
	AssociateIpAddressWithBodyWithResponse(ctx context.Context, network string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssociateIpAddressResponse, error)

	AssociateIpAddressWithResponse(ctx context.Context, network string, body AssociateIpAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*AssociateIpAddressResponse, error)

	// DestroyNetworkWithResponse request
	DestroyNetworkWithResponse(ctx context.Context, network string, reqEditors ...RequestEditorFn) (*DestroyNetworkResponse, error)

	// NetworkShowWithResponse request
	NetworkShowWithResponse(ctx context.Context, network string, reqEditors ...RequestEditorFn) (*NetworkShowResponse, error)

	// NetworkListWithResponse request
	NetworkListWithResponse(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*NetworkListResponse, error)

	// CreatePortForwardingWithBodyWithResponse request with any body
	CreatePortForwardingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePortForwardingResponse, error)

	CreatePortForwardingWithResponse(ctx context.Context, body CreatePortForwardingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePortForwardingResponse, error)

	// DestroyPortForwardingWithResponse request
	DestroyPortForwardingWithResponse(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*DestroyPortForwardingResponse, error)

	// ListPortForwardingWithResponse request
	ListPortForwardingWithResponse(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*ListPortForwardingResponse, error)

	// StoreWithBodyWithResponse request with any body
	StoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreResponse, error)

	StoreWithResponse(ctx context.Context, body StoreJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreResponse, error)

	// UpdateWithBodyWithResponse request with any body
	UpdateWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResponse, error)

	UpdateWithResponse(ctx context.Context, project string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResponse, error)

	// ListProjectsWithResponse request
	ListProjectsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error)

	// CreateSnapshotWithBodyWithResponse request with any body
	CreateSnapshotWithBodyWithResponse(ctx context.Context, blockStorage string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error)

	CreateSnapshotWithResponse(ctx context.Context, blockStorage string, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error)

	// RevertSnapshotWithResponse request
	RevertSnapshotWithResponse(ctx context.Context, snapshot string, reqEditors ...RequestEditorFn) (*RevertSnapshotResponse, error)

	// DestroySnapshotWithResponse request
	DestroySnapshotWithResponse(ctx context.Context, snapshot string, reqEditors ...RequestEditorFn) (*DestroySnapshotResponse, error)

	// ShowSnapshotWithResponse request
	ShowSnapshotWithResponse(ctx context.Context, snapshot string, reqEditors ...RequestEditorFn) (*ShowSnapshotResponse, error)

	// ListSnapshotWithResponse request
	ListSnapshotWithResponse(ctx context.Context, blockStorage string, project string, reqEditors ...RequestEditorFn) (*ListSnapshotResponse, error)

	// ListAclListWithResponse request
	ListAclListWithResponse(ctx context.Context, vpc string, reqEditors ...RequestEditorFn) (*ListAclListResponse, error)

	// DeleteAclListWithResponse request
	DeleteAclListWithResponse(ctx context.Context, vpc string, aclName string, reqEditors ...RequestEditorFn) (*DeleteAclListResponse, error)

	// VpcStoreWithBodyWithResponse request with any body
	VpcStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VpcStoreResponse, error)

	VpcStoreWithResponse(ctx context.Context, body VpcStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*VpcStoreResponse, error)

	// CreateAclListWithResponse request
	CreateAclListWithResponse(ctx context.Context, vpc string, reqEditors ...RequestEditorFn) (*CreateAclListResponse, error)

	// CreateAclWithBodyWithResponse request with any body
	CreateAclWithBodyWithResponse(ctx context.Context, vpc string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclResponse, error)

	CreateAclWithResponse(ctx context.Context, vpc string, body CreateAclJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclResponse, error)

	// UpdateAclListWithBodyWithResponse request with any body
	UpdateAclListWithBodyWithResponse(ctx context.Context, vpc string, aclName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAclListResponse, error)

	UpdateAclListWithResponse(ctx context.Context, vpc string, aclName string, body UpdateAclListJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAclListResponse, error)

	// DestroyWithResponse request
	DestroyWithResponse(ctx context.Context, vpc string, reqEditors ...RequestEditorFn) (*DestroyResponse, error)

	// ShowWithResponse request
	ShowWithResponse(ctx context.Context, vpc string, reqEditors ...RequestEditorFn) (*ShowResponse, error)

	// ListWithResponse request
	ListWithResponse(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*ListResponse, error)
}

type AttachBlockStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Attach BlockStorage Schema
		Data *AttachBlockStorageSchema `json:"data,omitempty"`

		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AttachBlockStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachBlockStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreBlockStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Batch Create Blockstorage Schema
		Batch *CreateBlockstorageSchema `json:"batch,omitempty"`

		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StoreBlockStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreBlockStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DetachBlockStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Detach BlockStorage Schema
		Data *DetachBlockStorageSchema `json:"data,omitempty"`

		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DetachBlockStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DetachBlockStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DestroyBlockStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Delete Block Storage Schema
		Data *DeleteBlockStorageSchema `json:"data,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DestroyBlockStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DestroyBlockStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowBlockStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockStorageSchema
}

// Status returns HTTPResponse.Status
func (r ShowBlockStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowBlockStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBlockStorageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlockStorageResource
}

// Status returns HTTPResponse.Status
func (r ListBlockStorageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBlockStorageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConfigClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KubernetesResource
}

// Status returns HTTPResponse.Status
func (r ConfigClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConfigClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreKubernetesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Batch Kubernetes Batch Schema
		Batch *KubernetesBatchSchema `json:"batch,omitempty"`

		// Data Create Kubernetes Schema
		Data *CreateKubernetesSchema `json:"data,omitempty"`

		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StoreKubernetesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreKubernetesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScaleClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ScaleClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScaleClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopKubernetesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StopKubernetesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopKubernetesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpgradeClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpgradeClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpgradeClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowKubernetesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KubernetesResource
}

// Status returns HTTPResponse.Status
func (r ShowKubernetesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowKubernetesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartKubernetesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StartKubernetesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartKubernetesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DestroyKubernetesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Delete Kubernetes Schema
		Data *DeleteKubernetesSchema `json:"data,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DestroyKubernetesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DestroyKubernetesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListKubernetesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KubernetesResource
}

// Status returns HTTPResponse.Status
func (r ListKubernetesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListKubernetesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFirewallResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateFirewallResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFirewallResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DestroyFirewallResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DestroyFirewallResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DestroyFirewallResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFirewallResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FirewallResource
}

// Status returns HTTPResponse.Status
func (r ListFirewallResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFirewallResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangeHostnameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ChangeHostnameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangeHostnameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Batch Create Instance Schema
		Batch *InstanceSchema `json:"batch,omitempty"`

		// Data Async Job Schema
		Data *AsyncJobSchema `json:"data,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StoreInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstancesOfferingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InstancesOfferingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstancesOfferingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RebootResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RebootResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RebootResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReinstallResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReinstallResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReinstallResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ResetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StopResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstancesTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InstancesTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstancesTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstanceDestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Delete Instance Schema
		Data *DeleteInstanceSchema `json:"data,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r InstanceDestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstanceDestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstancesShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InstanceResource
}

// Status returns HTTPResponse.Status
func (r InstancesShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstancesShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstancesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InstanceResource
}

// Status returns HTTPResponse.Status
func (r InstancesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstancesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadBalanceStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Batch Create Loadbalancer Schema
		Batch *CreateLoadbalancerBatchSchema `json:"batch,omitempty"`

		// Data Create Loadbalancer Schema
		Data *CreateLoadbalancerSchema `json:"data,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r LoadBalanceStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadBalanceStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Headers Remove Load Balancer Rule Schema
		Headers *RemoveLoadBalancerRuleSchema `json:"headers,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RemoveRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Batch Create Loadbalancer Schema
		Batch *CreateLoadbalancerBatchSchema `json:"batch,omitempty"`

		// Data Create Load Balancer Rule Schema
		Data *CreateLoadBalancerRuleSchema `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DestroyLoadBalancerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Batch Create Loadbalancer Schema
		Batch *CreateLoadbalancerBatchSchema `json:"batch,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DestroyLoadBalancerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DestroyLoadBalancerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadBalancerShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadBalancerResource
}

// Status returns HTTPResponse.Status
func (r LoadBalancerShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadBalancerShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadBalacnerUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r LoadBalacnerUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadBalacnerUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadBalancersListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadBalancerResource
}

// Status returns HTTPResponse.Status
func (r LoadBalancersListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadBalancersListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Network Schema
		Data *NetworkSchema `json:"data,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StoreNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableStaticNatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DisableStaticNatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableStaticNatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddEgressRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddEgressRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddEgressRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableStaticNatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EnableStaticNatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableStaticNatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisassociateIpAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DisassociateIpAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisassociateIpAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssociateIpAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Batch Public IP Address Schema
		Batch *PublicIpAddressSchema `json:"batch,omitempty"`

		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AssociateIpAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssociateIpAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DestroyNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Batch Delete Network Schema
		Batch *DeleteNetworkSchema `json:"batch,omitempty"`

		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DestroyNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DestroyNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NetworkShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkResource
}

// Status returns HTTPResponse.Status
func (r NetworkShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NetworkShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NetworkListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NetworkResource
}

// Status returns HTTPResponse.Status
func (r NetworkListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NetworkListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePortForwardingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreatePortForwardingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePortForwardingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DestroyPortForwardingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DestroyPortForwardingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DestroyPortForwardingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPortForwardingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PortForwardingResource
}

// Status returns HTTPResponse.Status
func (r ListPortForwardingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPortForwardingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Project Schema
		Data *ProjectSchema `json:"data,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Project Schema
		Data *ProjectSchema `json:"data,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectResource
}

// Status returns HTTPResponse.Status
func (r ListProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevertSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RevertSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevertSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DestroySnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DestroySnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DestroySnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SnapshotResource
}

// Status returns HTTPResponse.Status
func (r ShowSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SnapshotResource
}

// Status returns HTTPResponse.Status
func (r ListSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAclListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VpcResource
}

// Status returns HTTPResponse.Status
func (r ListAclListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAclListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAclListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteAclListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAclListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VpcStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Vpc Schema
		Data *VpcSchema `json:"data,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r VpcStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VpcStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAclListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateAclListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAclListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAclResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateAclResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAclResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAclListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateAclListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAclListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DestroyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Batch Delete Vpc Schema
		Batch *DeleteVpcSchema `json:"batch,omitempty"`

		// Job Async Job Schema
		Job *AsyncJobSchema `json:"job,omitempty"`

		// Message Ok
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DestroyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DestroyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VpcResource
}

// Status returns HTTPResponse.Status
func (r ShowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VpcResource
}

// Status returns HTTPResponse.Status
func (r ListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AttachBlockStorageWithBodyWithResponse request with arbitrary body returning *AttachBlockStorageResponse
func (c *ClientWithResponses) AttachBlockStorageWithBodyWithResponse(ctx context.Context, blockStorage string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachBlockStorageResponse, error) {
	rsp, err := c.AttachBlockStorageWithBody(ctx, blockStorage, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachBlockStorageResponse(rsp)
}

func (c *ClientWithResponses) AttachBlockStorageWithResponse(ctx context.Context, blockStorage string, body AttachBlockStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachBlockStorageResponse, error) {
	rsp, err := c.AttachBlockStorage(ctx, blockStorage, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachBlockStorageResponse(rsp)
}

// StoreBlockStorageWithBodyWithResponse request with arbitrary body returning *StoreBlockStorageResponse
func (c *ClientWithResponses) StoreBlockStorageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreBlockStorageResponse, error) {
	rsp, err := c.StoreBlockStorageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreBlockStorageResponse(rsp)
}

func (c *ClientWithResponses) StoreBlockStorageWithResponse(ctx context.Context, body StoreBlockStorageJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreBlockStorageResponse, error) {
	rsp, err := c.StoreBlockStorage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreBlockStorageResponse(rsp)
}

// DetachBlockStorageWithResponse request returning *DetachBlockStorageResponse
func (c *ClientWithResponses) DetachBlockStorageWithResponse(ctx context.Context, blockStorage string, reqEditors ...RequestEditorFn) (*DetachBlockStorageResponse, error) {
	rsp, err := c.DetachBlockStorage(ctx, blockStorage, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDetachBlockStorageResponse(rsp)
}

// DestroyBlockStorageWithResponse request returning *DestroyBlockStorageResponse
func (c *ClientWithResponses) DestroyBlockStorageWithResponse(ctx context.Context, blockStorage string, reqEditors ...RequestEditorFn) (*DestroyBlockStorageResponse, error) {
	rsp, err := c.DestroyBlockStorage(ctx, blockStorage, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDestroyBlockStorageResponse(rsp)
}

// ShowBlockStorageWithResponse request returning *ShowBlockStorageResponse
func (c *ClientWithResponses) ShowBlockStorageWithResponse(ctx context.Context, blockStorage string, reqEditors ...RequestEditorFn) (*ShowBlockStorageResponse, error) {
	rsp, err := c.ShowBlockStorage(ctx, blockStorage, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowBlockStorageResponse(rsp)
}

// ListBlockStorageWithResponse request returning *ListBlockStorageResponse
func (c *ClientWithResponses) ListBlockStorageWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListBlockStorageResponse, error) {
	rsp, err := c.ListBlockStorage(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBlockStorageResponse(rsp)
}

// ConfigClusterWithResponse request returning *ConfigClusterResponse
func (c *ClientWithResponses) ConfigClusterWithResponse(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*ConfigClusterResponse, error) {
	rsp, err := c.ConfigCluster(ctx, kubernetes, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConfigClusterResponse(rsp)
}

// StoreKubernetesWithBodyWithResponse request with arbitrary body returning *StoreKubernetesResponse
func (c *ClientWithResponses) StoreKubernetesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreKubernetesResponse, error) {
	rsp, err := c.StoreKubernetesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreKubernetesResponse(rsp)
}

func (c *ClientWithResponses) StoreKubernetesWithResponse(ctx context.Context, body StoreKubernetesJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreKubernetesResponse, error) {
	rsp, err := c.StoreKubernetes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreKubernetesResponse(rsp)
}

// ScaleClusterWithBodyWithResponse request with arbitrary body returning *ScaleClusterResponse
func (c *ClientWithResponses) ScaleClusterWithBodyWithResponse(ctx context.Context, kubernetes string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScaleClusterResponse, error) {
	rsp, err := c.ScaleClusterWithBody(ctx, kubernetes, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScaleClusterResponse(rsp)
}

func (c *ClientWithResponses) ScaleClusterWithResponse(ctx context.Context, kubernetes string, body ScaleClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*ScaleClusterResponse, error) {
	rsp, err := c.ScaleCluster(ctx, kubernetes, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScaleClusterResponse(rsp)
}

// StopKubernetesWithResponse request returning *StopKubernetesResponse
func (c *ClientWithResponses) StopKubernetesWithResponse(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*StopKubernetesResponse, error) {
	rsp, err := c.StopKubernetes(ctx, kubernetes, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopKubernetesResponse(rsp)
}

// UpgradeClusterWithBodyWithResponse request with arbitrary body returning *UpgradeClusterResponse
func (c *ClientWithResponses) UpgradeClusterWithBodyWithResponse(ctx context.Context, kubernetes string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpgradeClusterResponse, error) {
	rsp, err := c.UpgradeClusterWithBody(ctx, kubernetes, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpgradeClusterResponse(rsp)
}

func (c *ClientWithResponses) UpgradeClusterWithResponse(ctx context.Context, kubernetes string, body UpgradeClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpgradeClusterResponse, error) {
	rsp, err := c.UpgradeCluster(ctx, kubernetes, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpgradeClusterResponse(rsp)
}

// ShowKubernetesWithResponse request returning *ShowKubernetesResponse
func (c *ClientWithResponses) ShowKubernetesWithResponse(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*ShowKubernetesResponse, error) {
	rsp, err := c.ShowKubernetes(ctx, kubernetes, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowKubernetesResponse(rsp)
}

// StartKubernetesWithResponse request returning *StartKubernetesResponse
func (c *ClientWithResponses) StartKubernetesWithResponse(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*StartKubernetesResponse, error) {
	rsp, err := c.StartKubernetes(ctx, kubernetes, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartKubernetesResponse(rsp)
}

// DestroyKubernetesWithResponse request returning *DestroyKubernetesResponse
func (c *ClientWithResponses) DestroyKubernetesWithResponse(ctx context.Context, kubernetes string, reqEditors ...RequestEditorFn) (*DestroyKubernetesResponse, error) {
	rsp, err := c.DestroyKubernetes(ctx, kubernetes, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDestroyKubernetesResponse(rsp)
}

// ListKubernetesWithResponse request returning *ListKubernetesResponse
func (c *ClientWithResponses) ListKubernetesWithResponse(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*ListKubernetesResponse, error) {
	rsp, err := c.ListKubernetes(ctx, project, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListKubernetesResponse(rsp)
}

// CreateFirewallWithBodyWithResponse request with arbitrary body returning *CreateFirewallResponse
func (c *ClientWithResponses) CreateFirewallWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFirewallResponse, error) {
	rsp, err := c.CreateFirewallWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFirewallResponse(rsp)
}

func (c *ClientWithResponses) CreateFirewallWithResponse(ctx context.Context, body CreateFirewallJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFirewallResponse, error) {
	rsp, err := c.CreateFirewall(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFirewallResponse(rsp)
}

// DestroyFirewallWithResponse request returning *DestroyFirewallResponse
func (c *ClientWithResponses) DestroyFirewallWithResponse(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*DestroyFirewallResponse, error) {
	rsp, err := c.DestroyFirewall(ctx, ipAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDestroyFirewallResponse(rsp)
}

// ListFirewallWithResponse request returning *ListFirewallResponse
func (c *ClientWithResponses) ListFirewallWithResponse(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*ListFirewallResponse, error) {
	rsp, err := c.ListFirewall(ctx, ipAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFirewallResponse(rsp)
}

// ChangeHostnameWithBodyWithResponse request with arbitrary body returning *ChangeHostnameResponse
func (c *ClientWithResponses) ChangeHostnameWithBodyWithResponse(ctx context.Context, instance string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangeHostnameResponse, error) {
	rsp, err := c.ChangeHostnameWithBody(ctx, instance, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeHostnameResponse(rsp)
}

func (c *ClientWithResponses) ChangeHostnameWithResponse(ctx context.Context, instance string, body ChangeHostnameJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangeHostnameResponse, error) {
	rsp, err := c.ChangeHostname(ctx, instance, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangeHostnameResponse(rsp)
}

// StoreInstanceWithBodyWithResponse request with arbitrary body returning *StoreInstanceResponse
func (c *ClientWithResponses) StoreInstanceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreInstanceResponse, error) {
	rsp, err := c.StoreInstanceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreInstanceResponse(rsp)
}

func (c *ClientWithResponses) StoreInstanceWithResponse(ctx context.Context, body StoreInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreInstanceResponse, error) {
	rsp, err := c.StoreInstance(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreInstanceResponse(rsp)
}

// InstancesOfferingsWithResponse request returning *InstancesOfferingsResponse
func (c *ClientWithResponses) InstancesOfferingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InstancesOfferingsResponse, error) {
	rsp, err := c.InstancesOfferings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstancesOfferingsResponse(rsp)
}

// RebootWithResponse request returning *RebootResponse
func (c *ClientWithResponses) RebootWithResponse(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*RebootResponse, error) {
	rsp, err := c.Reboot(ctx, instance, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRebootResponse(rsp)
}

// ReinstallWithResponse request returning *ReinstallResponse
func (c *ClientWithResponses) ReinstallWithResponse(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*ReinstallResponse, error) {
	rsp, err := c.Reinstall(ctx, instance, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReinstallResponse(rsp)
}

// ResetPasswordWithResponse request returning *ResetPasswordResponse
func (c *ClientWithResponses) ResetPasswordWithResponse(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPassword(ctx, instance, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

// StartWithResponse request returning *StartResponse
func (c *ClientWithResponses) StartWithResponse(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*StartResponse, error) {
	rsp, err := c.Start(ctx, instance, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartResponse(rsp)
}

// StopWithResponse request returning *StopResponse
func (c *ClientWithResponses) StopWithResponse(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*StopResponse, error) {
	rsp, err := c.Stop(ctx, instance, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopResponse(rsp)
}

// InstancesTemplateWithResponse request returning *InstancesTemplateResponse
func (c *ClientWithResponses) InstancesTemplateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InstancesTemplateResponse, error) {
	rsp, err := c.InstancesTemplate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstancesTemplateResponse(rsp)
}

// InstanceDestroyWithResponse request returning *InstanceDestroyResponse
func (c *ClientWithResponses) InstanceDestroyWithResponse(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*InstanceDestroyResponse, error) {
	rsp, err := c.InstanceDestroy(ctx, instance, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstanceDestroyResponse(rsp)
}

// InstancesShowWithResponse request returning *InstancesShowResponse
func (c *ClientWithResponses) InstancesShowWithResponse(ctx context.Context, instance string, reqEditors ...RequestEditorFn) (*InstancesShowResponse, error) {
	rsp, err := c.InstancesShow(ctx, instance, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstancesShowResponse(rsp)
}

// InstancesListWithResponse request returning *InstancesListResponse
func (c *ClientWithResponses) InstancesListWithResponse(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*InstancesListResponse, error) {
	rsp, err := c.InstancesList(ctx, project, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstancesListResponse(rsp)
}

// LoadBalanceStoreWithBodyWithResponse request with arbitrary body returning *LoadBalanceStoreResponse
func (c *ClientWithResponses) LoadBalanceStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoadBalanceStoreResponse, error) {
	rsp, err := c.LoadBalanceStoreWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadBalanceStoreResponse(rsp)
}

func (c *ClientWithResponses) LoadBalanceStoreWithResponse(ctx context.Context, body LoadBalanceStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*LoadBalanceStoreResponse, error) {
	rsp, err := c.LoadBalanceStore(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadBalanceStoreResponse(rsp)
}

// RemoveRuleWithBodyWithResponse request with arbitrary body returning *RemoveRuleResponse
func (c *ClientWithResponses) RemoveRuleWithBodyWithResponse(ctx context.Context, loadBalancer string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveRuleResponse, error) {
	rsp, err := c.RemoveRuleWithBody(ctx, loadBalancer, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRuleResponse(rsp)
}

func (c *ClientWithResponses) RemoveRuleWithResponse(ctx context.Context, loadBalancer string, body RemoveRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveRuleResponse, error) {
	rsp, err := c.RemoveRule(ctx, loadBalancer, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveRuleResponse(rsp)
}

// AddRuleWithBodyWithResponse request with arbitrary body returning *AddRuleResponse
func (c *ClientWithResponses) AddRuleWithBodyWithResponse(ctx context.Context, loadBalancer string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRuleResponse, error) {
	rsp, err := c.AddRuleWithBody(ctx, loadBalancer, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRuleResponse(rsp)
}

func (c *ClientWithResponses) AddRuleWithResponse(ctx context.Context, loadBalancer string, body AddRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRuleResponse, error) {
	rsp, err := c.AddRule(ctx, loadBalancer, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRuleResponse(rsp)
}

// DestroyLoadBalancerWithResponse request returning *DestroyLoadBalancerResponse
func (c *ClientWithResponses) DestroyLoadBalancerWithResponse(ctx context.Context, loadBalancer string, reqEditors ...RequestEditorFn) (*DestroyLoadBalancerResponse, error) {
	rsp, err := c.DestroyLoadBalancer(ctx, loadBalancer, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDestroyLoadBalancerResponse(rsp)
}

// LoadBalancerShowWithResponse request returning *LoadBalancerShowResponse
func (c *ClientWithResponses) LoadBalancerShowWithResponse(ctx context.Context, loadBalancer string, reqEditors ...RequestEditorFn) (*LoadBalancerShowResponse, error) {
	rsp, err := c.LoadBalancerShow(ctx, loadBalancer, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadBalancerShowResponse(rsp)
}

// LoadBalacnerUpdateWithBodyWithResponse request with arbitrary body returning *LoadBalacnerUpdateResponse
func (c *ClientWithResponses) LoadBalacnerUpdateWithBodyWithResponse(ctx context.Context, loadBalancer string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoadBalacnerUpdateResponse, error) {
	rsp, err := c.LoadBalacnerUpdateWithBody(ctx, loadBalancer, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadBalacnerUpdateResponse(rsp)
}

func (c *ClientWithResponses) LoadBalacnerUpdateWithResponse(ctx context.Context, loadBalancer string, body LoadBalacnerUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*LoadBalacnerUpdateResponse, error) {
	rsp, err := c.LoadBalacnerUpdate(ctx, loadBalancer, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadBalacnerUpdateResponse(rsp)
}

// LoadBalancersListWithResponse request returning *LoadBalancersListResponse
func (c *ClientWithResponses) LoadBalancersListWithResponse(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*LoadBalancersListResponse, error) {
	rsp, err := c.LoadBalancersList(ctx, project, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadBalancersListResponse(rsp)
}

// StoreNetworkWithBodyWithResponse request with arbitrary body returning *StoreNetworkResponse
func (c *ClientWithResponses) StoreNetworkWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreNetworkResponse, error) {
	rsp, err := c.StoreNetworkWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreNetworkResponse(rsp)
}

func (c *ClientWithResponses) StoreNetworkWithResponse(ctx context.Context, body StoreNetworkJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreNetworkResponse, error) {
	rsp, err := c.StoreNetwork(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreNetworkResponse(rsp)
}

// DisableStaticNatWithResponse request returning *DisableStaticNatResponse
func (c *ClientWithResponses) DisableStaticNatWithResponse(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*DisableStaticNatResponse, error) {
	rsp, err := c.DisableStaticNat(ctx, ipAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableStaticNatResponse(rsp)
}

// DeleteRuleWithBodyWithResponse request with arbitrary body returning *DeleteRuleResponse
func (c *ClientWithResponses) DeleteRuleWithBodyWithResponse(ctx context.Context, network string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error) {
	rsp, err := c.DeleteRuleWithBody(ctx, network, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuleResponse(rsp)
}

func (c *ClientWithResponses) DeleteRuleWithResponse(ctx context.Context, network string, body DeleteRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error) {
	rsp, err := c.DeleteRule(ctx, network, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuleResponse(rsp)
}

// AddEgressRuleWithBodyWithResponse request with arbitrary body returning *AddEgressRuleResponse
func (c *ClientWithResponses) AddEgressRuleWithBodyWithResponse(ctx context.Context, network string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddEgressRuleResponse, error) {
	rsp, err := c.AddEgressRuleWithBody(ctx, network, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddEgressRuleResponse(rsp)
}

func (c *ClientWithResponses) AddEgressRuleWithResponse(ctx context.Context, network string, body AddEgressRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*AddEgressRuleResponse, error) {
	rsp, err := c.AddEgressRule(ctx, network, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddEgressRuleResponse(rsp)
}

// EnableStaticNatWithBodyWithResponse request with arbitrary body returning *EnableStaticNatResponse
func (c *ClientWithResponses) EnableStaticNatWithBodyWithResponse(ctx context.Context, ipAddress string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableStaticNatResponse, error) {
	rsp, err := c.EnableStaticNatWithBody(ctx, ipAddress, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableStaticNatResponse(rsp)
}

func (c *ClientWithResponses) EnableStaticNatWithResponse(ctx context.Context, ipAddress string, body EnableStaticNatJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableStaticNatResponse, error) {
	rsp, err := c.EnableStaticNat(ctx, ipAddress, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableStaticNatResponse(rsp)
}

// DisassociateIpAddressWithResponse request returning *DisassociateIpAddressResponse
func (c *ClientWithResponses) DisassociateIpAddressWithResponse(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*DisassociateIpAddressResponse, error) {
	rsp, err := c.DisassociateIpAddress(ctx, ipAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisassociateIpAddressResponse(rsp)
}

// AssociateIpAddressWithBodyWithResponse request with arbitrary body returning *AssociateIpAddressResponse
func (c *ClientWithResponses) AssociateIpAddressWithBodyWithResponse(ctx context.Context, network string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AssociateIpAddressResponse, error) {
	rsp, err := c.AssociateIpAddressWithBody(ctx, network, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssociateIpAddressResponse(rsp)
}

func (c *ClientWithResponses) AssociateIpAddressWithResponse(ctx context.Context, network string, body AssociateIpAddressJSONRequestBody, reqEditors ...RequestEditorFn) (*AssociateIpAddressResponse, error) {
	rsp, err := c.AssociateIpAddress(ctx, network, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssociateIpAddressResponse(rsp)
}

// DestroyNetworkWithResponse request returning *DestroyNetworkResponse
func (c *ClientWithResponses) DestroyNetworkWithResponse(ctx context.Context, network string, reqEditors ...RequestEditorFn) (*DestroyNetworkResponse, error) {
	rsp, err := c.DestroyNetwork(ctx, network, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDestroyNetworkResponse(rsp)
}

// NetworkShowWithResponse request returning *NetworkShowResponse
func (c *ClientWithResponses) NetworkShowWithResponse(ctx context.Context, network string, reqEditors ...RequestEditorFn) (*NetworkShowResponse, error) {
	rsp, err := c.NetworkShow(ctx, network, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworkShowResponse(rsp)
}

// NetworkListWithResponse request returning *NetworkListResponse
func (c *ClientWithResponses) NetworkListWithResponse(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*NetworkListResponse, error) {
	rsp, err := c.NetworkList(ctx, project, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNetworkListResponse(rsp)
}

// CreatePortForwardingWithBodyWithResponse request with arbitrary body returning *CreatePortForwardingResponse
func (c *ClientWithResponses) CreatePortForwardingWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePortForwardingResponse, error) {
	rsp, err := c.CreatePortForwardingWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePortForwardingResponse(rsp)
}

func (c *ClientWithResponses) CreatePortForwardingWithResponse(ctx context.Context, body CreatePortForwardingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePortForwardingResponse, error) {
	rsp, err := c.CreatePortForwarding(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePortForwardingResponse(rsp)
}

// DestroyPortForwardingWithResponse request returning *DestroyPortForwardingResponse
func (c *ClientWithResponses) DestroyPortForwardingWithResponse(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*DestroyPortForwardingResponse, error) {
	rsp, err := c.DestroyPortForwarding(ctx, ipAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDestroyPortForwardingResponse(rsp)
}

// ListPortForwardingWithResponse request returning *ListPortForwardingResponse
func (c *ClientWithResponses) ListPortForwardingWithResponse(ctx context.Context, ipAddress string, reqEditors ...RequestEditorFn) (*ListPortForwardingResponse, error) {
	rsp, err := c.ListPortForwarding(ctx, ipAddress, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPortForwardingResponse(rsp)
}

// StoreWithBodyWithResponse request with arbitrary body returning *StoreResponse
func (c *ClientWithResponses) StoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StoreResponse, error) {
	rsp, err := c.StoreWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreResponse(rsp)
}

func (c *ClientWithResponses) StoreWithResponse(ctx context.Context, body StoreJSONRequestBody, reqEditors ...RequestEditorFn) (*StoreResponse, error) {
	rsp, err := c.Store(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStoreResponse(rsp)
}

// UpdateWithBodyWithResponse request with arbitrary body returning *UpdateResponse
func (c *ClientWithResponses) UpdateWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateResponse, error) {
	rsp, err := c.UpdateWithBody(ctx, project, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResponse(rsp)
}

func (c *ClientWithResponses) UpdateWithResponse(ctx context.Context, project string, body UpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateResponse, error) {
	rsp, err := c.Update(ctx, project, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateResponse(rsp)
}

// ListProjectsWithResponse request returning *ListProjectsResponse
func (c *ClientWithResponses) ListProjectsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error) {
	rsp, err := c.ListProjects(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectsResponse(rsp)
}

// CreateSnapshotWithBodyWithResponse request with arbitrary body returning *CreateSnapshotResponse
func (c *ClientWithResponses) CreateSnapshotWithBodyWithResponse(ctx context.Context, blockStorage string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error) {
	rsp, err := c.CreateSnapshotWithBody(ctx, blockStorage, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSnapshotResponse(rsp)
}

func (c *ClientWithResponses) CreateSnapshotWithResponse(ctx context.Context, blockStorage string, body CreateSnapshotJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSnapshotResponse, error) {
	rsp, err := c.CreateSnapshot(ctx, blockStorage, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSnapshotResponse(rsp)
}

// RevertSnapshotWithResponse request returning *RevertSnapshotResponse
func (c *ClientWithResponses) RevertSnapshotWithResponse(ctx context.Context, snapshot string, reqEditors ...RequestEditorFn) (*RevertSnapshotResponse, error) {
	rsp, err := c.RevertSnapshot(ctx, snapshot, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevertSnapshotResponse(rsp)
}

// DestroySnapshotWithResponse request returning *DestroySnapshotResponse
func (c *ClientWithResponses) DestroySnapshotWithResponse(ctx context.Context, snapshot string, reqEditors ...RequestEditorFn) (*DestroySnapshotResponse, error) {
	rsp, err := c.DestroySnapshot(ctx, snapshot, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDestroySnapshotResponse(rsp)
}

// ShowSnapshotWithResponse request returning *ShowSnapshotResponse
func (c *ClientWithResponses) ShowSnapshotWithResponse(ctx context.Context, snapshot string, reqEditors ...RequestEditorFn) (*ShowSnapshotResponse, error) {
	rsp, err := c.ShowSnapshot(ctx, snapshot, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowSnapshotResponse(rsp)
}

// ListSnapshotWithResponse request returning *ListSnapshotResponse
func (c *ClientWithResponses) ListSnapshotWithResponse(ctx context.Context, blockStorage string, project string, reqEditors ...RequestEditorFn) (*ListSnapshotResponse, error) {
	rsp, err := c.ListSnapshot(ctx, blockStorage, project, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSnapshotResponse(rsp)
}

// ListAclListWithResponse request returning *ListAclListResponse
func (c *ClientWithResponses) ListAclListWithResponse(ctx context.Context, vpc string, reqEditors ...RequestEditorFn) (*ListAclListResponse, error) {
	rsp, err := c.ListAclList(ctx, vpc, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAclListResponse(rsp)
}

// DeleteAclListWithResponse request returning *DeleteAclListResponse
func (c *ClientWithResponses) DeleteAclListWithResponse(ctx context.Context, vpc string, aclName string, reqEditors ...RequestEditorFn) (*DeleteAclListResponse, error) {
	rsp, err := c.DeleteAclList(ctx, vpc, aclName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAclListResponse(rsp)
}

// VpcStoreWithBodyWithResponse request with arbitrary body returning *VpcStoreResponse
func (c *ClientWithResponses) VpcStoreWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VpcStoreResponse, error) {
	rsp, err := c.VpcStoreWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVpcStoreResponse(rsp)
}

func (c *ClientWithResponses) VpcStoreWithResponse(ctx context.Context, body VpcStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*VpcStoreResponse, error) {
	rsp, err := c.VpcStore(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVpcStoreResponse(rsp)
}

// CreateAclListWithResponse request returning *CreateAclListResponse
func (c *ClientWithResponses) CreateAclListWithResponse(ctx context.Context, vpc string, reqEditors ...RequestEditorFn) (*CreateAclListResponse, error) {
	rsp, err := c.CreateAclList(ctx, vpc, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclListResponse(rsp)
}

// CreateAclWithBodyWithResponse request with arbitrary body returning *CreateAclResponse
func (c *ClientWithResponses) CreateAclWithBodyWithResponse(ctx context.Context, vpc string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclResponse, error) {
	rsp, err := c.CreateAclWithBody(ctx, vpc, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclResponse(rsp)
}

func (c *ClientWithResponses) CreateAclWithResponse(ctx context.Context, vpc string, body CreateAclJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclResponse, error) {
	rsp, err := c.CreateAcl(ctx, vpc, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclResponse(rsp)
}

// UpdateAclListWithBodyWithResponse request with arbitrary body returning *UpdateAclListResponse
func (c *ClientWithResponses) UpdateAclListWithBodyWithResponse(ctx context.Context, vpc string, aclName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAclListResponse, error) {
	rsp, err := c.UpdateAclListWithBody(ctx, vpc, aclName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAclListResponse(rsp)
}

func (c *ClientWithResponses) UpdateAclListWithResponse(ctx context.Context, vpc string, aclName string, body UpdateAclListJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAclListResponse, error) {
	rsp, err := c.UpdateAclList(ctx, vpc, aclName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAclListResponse(rsp)
}

// DestroyWithResponse request returning *DestroyResponse
func (c *ClientWithResponses) DestroyWithResponse(ctx context.Context, vpc string, reqEditors ...RequestEditorFn) (*DestroyResponse, error) {
	rsp, err := c.Destroy(ctx, vpc, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDestroyResponse(rsp)
}

// ShowWithResponse request returning *ShowResponse
func (c *ClientWithResponses) ShowWithResponse(ctx context.Context, vpc string, reqEditors ...RequestEditorFn) (*ShowResponse, error) {
	rsp, err := c.Show(ctx, vpc, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowResponse(rsp)
}

// ListWithResponse request returning *ListResponse
func (c *ClientWithResponses) ListWithResponse(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*ListResponse, error) {
	rsp, err := c.List(ctx, project, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListResponse(rsp)
}

// ParseAttachBlockStorageResponse parses an HTTP response from a AttachBlockStorageWithResponse call
func ParseAttachBlockStorageResponse(rsp *http.Response) (*AttachBlockStorageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachBlockStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Attach BlockStorage Schema
			Data *AttachBlockStorageSchema `json:"data,omitempty"`

			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreBlockStorageResponse parses an HTTP response from a StoreBlockStorageWithResponse call
func ParseStoreBlockStorageResponse(rsp *http.Response) (*StoreBlockStorageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreBlockStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Batch Create Blockstorage Schema
			Batch *CreateBlockstorageSchema `json:"batch,omitempty"`

			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDetachBlockStorageResponse parses an HTTP response from a DetachBlockStorageWithResponse call
func ParseDetachBlockStorageResponse(rsp *http.Response) (*DetachBlockStorageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DetachBlockStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Detach BlockStorage Schema
			Data *DetachBlockStorageSchema `json:"data,omitempty"`

			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDestroyBlockStorageResponse parses an HTTP response from a DestroyBlockStorageWithResponse call
func ParseDestroyBlockStorageResponse(rsp *http.Response) (*DestroyBlockStorageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DestroyBlockStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Delete Block Storage Schema
			Data *DeleteBlockStorageSchema `json:"data,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseShowBlockStorageResponse parses an HTTP response from a ShowBlockStorageWithResponse call
func ParseShowBlockStorageResponse(rsp *http.Response) (*ShowBlockStorageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowBlockStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockStorageSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBlockStorageResponse parses an HTTP response from a ListBlockStorageWithResponse call
func ParseListBlockStorageResponse(rsp *http.Response) (*ListBlockStorageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBlockStorageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlockStorageResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseConfigClusterResponse parses an HTTP response from a ConfigClusterWithResponse call
func ParseConfigClusterResponse(rsp *http.Response) (*ConfigClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConfigClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KubernetesResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreKubernetesResponse parses an HTTP response from a StoreKubernetesWithResponse call
func ParseStoreKubernetesResponse(rsp *http.Response) (*StoreKubernetesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreKubernetesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Batch Kubernetes Batch Schema
			Batch *KubernetesBatchSchema `json:"batch,omitempty"`

			// Data Create Kubernetes Schema
			Data *CreateKubernetesSchema `json:"data,omitempty"`

			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScaleClusterResponse parses an HTTP response from a ScaleClusterWithResponse call
func ParseScaleClusterResponse(rsp *http.Response) (*ScaleClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScaleClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStopKubernetesResponse parses an HTTP response from a StopKubernetesWithResponse call
func ParseStopKubernetesResponse(rsp *http.Response) (*StopKubernetesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopKubernetesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpgradeClusterResponse parses an HTTP response from a UpgradeClusterWithResponse call
func ParseUpgradeClusterResponse(rsp *http.Response) (*UpgradeClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpgradeClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseShowKubernetesResponse parses an HTTP response from a ShowKubernetesWithResponse call
func ParseShowKubernetesResponse(rsp *http.Response) (*ShowKubernetesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowKubernetesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KubernetesResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStartKubernetesResponse parses an HTTP response from a StartKubernetesWithResponse call
func ParseStartKubernetesResponse(rsp *http.Response) (*StartKubernetesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartKubernetesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDestroyKubernetesResponse parses an HTTP response from a DestroyKubernetesWithResponse call
func ParseDestroyKubernetesResponse(rsp *http.Response) (*DestroyKubernetesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DestroyKubernetesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Delete Kubernetes Schema
			Data *DeleteKubernetesSchema `json:"data,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListKubernetesResponse parses an HTTP response from a ListKubernetesWithResponse call
func ParseListKubernetesResponse(rsp *http.Response) (*ListKubernetesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListKubernetesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KubernetesResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateFirewallResponse parses an HTTP response from a CreateFirewallWithResponse call
func ParseCreateFirewallResponse(rsp *http.Response) (*CreateFirewallResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFirewallResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDestroyFirewallResponse parses an HTTP response from a DestroyFirewallWithResponse call
func ParseDestroyFirewallResponse(rsp *http.Response) (*DestroyFirewallResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DestroyFirewallResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListFirewallResponse parses an HTTP response from a ListFirewallWithResponse call
func ParseListFirewallResponse(rsp *http.Response) (*ListFirewallResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFirewallResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FirewallResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseChangeHostnameResponse parses an HTTP response from a ChangeHostnameWithResponse call
func ParseChangeHostnameResponse(rsp *http.Response) (*ChangeHostnameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangeHostnameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreInstanceResponse parses an HTTP response from a StoreInstanceWithResponse call
func ParseStoreInstanceResponse(rsp *http.Response) (*StoreInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Batch Create Instance Schema
			Batch *InstanceSchema `json:"batch,omitempty"`

			// Data Async Job Schema
			Data *AsyncJobSchema `json:"data,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInstancesOfferingsResponse parses an HTTP response from a InstancesOfferingsWithResponse call
func ParseInstancesOfferingsResponse(rsp *http.Response) (*InstancesOfferingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstancesOfferingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRebootResponse parses an HTTP response from a RebootWithResponse call
func ParseRebootResponse(rsp *http.Response) (*RebootResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RebootResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReinstallResponse parses an HTTP response from a ReinstallWithResponse call
func ParseReinstallResponse(rsp *http.Response) (*ReinstallResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReinstallResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResetPasswordResponse parses an HTTP response from a ResetPasswordWithResponse call
func ParseResetPasswordResponse(rsp *http.Response) (*ResetPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStartResponse parses an HTTP response from a StartWithResponse call
func ParseStartResponse(rsp *http.Response) (*StartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStopResponse parses an HTTP response from a StopWithResponse call
func ParseStopResponse(rsp *http.Response) (*StopResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInstancesTemplateResponse parses an HTTP response from a InstancesTemplateWithResponse call
func ParseInstancesTemplateResponse(rsp *http.Response) (*InstancesTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstancesTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInstanceDestroyResponse parses an HTTP response from a InstanceDestroyWithResponse call
func ParseInstanceDestroyResponse(rsp *http.Response) (*InstanceDestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstanceDestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Delete Instance Schema
			Data *DeleteInstanceSchema `json:"data,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInstancesShowResponse parses an HTTP response from a InstancesShowWithResponse call
func ParseInstancesShowResponse(rsp *http.Response) (*InstancesShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstancesShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InstanceResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInstancesListResponse parses an HTTP response from a InstancesListWithResponse call
func ParseInstancesListResponse(rsp *http.Response) (*InstancesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstancesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InstanceResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoadBalanceStoreResponse parses an HTTP response from a LoadBalanceStoreWithResponse call
func ParseLoadBalanceStoreResponse(rsp *http.Response) (*LoadBalanceStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadBalanceStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Batch Create Loadbalancer Schema
			Batch *CreateLoadbalancerBatchSchema `json:"batch,omitempty"`

			// Data Create Loadbalancer Schema
			Data *CreateLoadbalancerSchema `json:"data,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveRuleResponse parses an HTTP response from a RemoveRuleWithResponse call
func ParseRemoveRuleResponse(rsp *http.Response) (*RemoveRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Headers Remove Load Balancer Rule Schema
			Headers *RemoveLoadBalancerRuleSchema `json:"headers,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddRuleResponse parses an HTTP response from a AddRuleWithResponse call
func ParseAddRuleResponse(rsp *http.Response) (*AddRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Batch Create Loadbalancer Schema
			Batch *CreateLoadbalancerBatchSchema `json:"batch,omitempty"`

			// Data Create Load Balancer Rule Schema
			Data *CreateLoadBalancerRuleSchema `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDestroyLoadBalancerResponse parses an HTTP response from a DestroyLoadBalancerWithResponse call
func ParseDestroyLoadBalancerResponse(rsp *http.Response) (*DestroyLoadBalancerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DestroyLoadBalancerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Batch Create Loadbalancer Schema
			Batch *CreateLoadbalancerBatchSchema `json:"batch,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoadBalancerShowResponse parses an HTTP response from a LoadBalancerShowWithResponse call
func ParseLoadBalancerShowResponse(rsp *http.Response) (*LoadBalancerShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadBalancerShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadBalancerResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoadBalacnerUpdateResponse parses an HTTP response from a LoadBalacnerUpdateWithResponse call
func ParseLoadBalacnerUpdateResponse(rsp *http.Response) (*LoadBalacnerUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadBalacnerUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoadBalancersListResponse parses an HTTP response from a LoadBalancersListWithResponse call
func ParseLoadBalancersListResponse(rsp *http.Response) (*LoadBalancersListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadBalancersListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadBalancerResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreNetworkResponse parses an HTTP response from a StoreNetworkWithResponse call
func ParseStoreNetworkResponse(rsp *http.Response) (*StoreNetworkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Network Schema
			Data *NetworkSchema `json:"data,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDisableStaticNatResponse parses an HTTP response from a DisableStaticNatWithResponse call
func ParseDisableStaticNatResponse(rsp *http.Response) (*DisableStaticNatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableStaticNatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteRuleResponse parses an HTTP response from a DeleteRuleWithResponse call
func ParseDeleteRuleResponse(rsp *http.Response) (*DeleteRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddEgressRuleResponse parses an HTTP response from a AddEgressRuleWithResponse call
func ParseAddEgressRuleResponse(rsp *http.Response) (*AddEgressRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddEgressRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnableStaticNatResponse parses an HTTP response from a EnableStaticNatWithResponse call
func ParseEnableStaticNatResponse(rsp *http.Response) (*EnableStaticNatResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableStaticNatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDisassociateIpAddressResponse parses an HTTP response from a DisassociateIpAddressWithResponse call
func ParseDisassociateIpAddressResponse(rsp *http.Response) (*DisassociateIpAddressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisassociateIpAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAssociateIpAddressResponse parses an HTTP response from a AssociateIpAddressWithResponse call
func ParseAssociateIpAddressResponse(rsp *http.Response) (*AssociateIpAddressResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssociateIpAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Batch Public IP Address Schema
			Batch *PublicIpAddressSchema `json:"batch,omitempty"`

			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDestroyNetworkResponse parses an HTTP response from a DestroyNetworkWithResponse call
func ParseDestroyNetworkResponse(rsp *http.Response) (*DestroyNetworkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DestroyNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Batch Delete Network Schema
			Batch *DeleteNetworkSchema `json:"batch,omitempty"`

			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNetworkShowResponse parses an HTTP response from a NetworkShowWithResponse call
func ParseNetworkShowResponse(rsp *http.Response) (*NetworkShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NetworkShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNetworkListResponse parses an HTTP response from a NetworkListWithResponse call
func ParseNetworkListResponse(rsp *http.Response) (*NetworkListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NetworkListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NetworkResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePortForwardingResponse parses an HTTP response from a CreatePortForwardingWithResponse call
func ParseCreatePortForwardingResponse(rsp *http.Response) (*CreatePortForwardingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePortForwardingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDestroyPortForwardingResponse parses an HTTP response from a DestroyPortForwardingWithResponse call
func ParseDestroyPortForwardingResponse(rsp *http.Response) (*DestroyPortForwardingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DestroyPortForwardingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPortForwardingResponse parses an HTTP response from a ListPortForwardingWithResponse call
func ParseListPortForwardingResponse(rsp *http.Response) (*ListPortForwardingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPortForwardingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PortForwardingResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStoreResponse parses an HTTP response from a StoreWithResponse call
func ParseStoreResponse(rsp *http.Response) (*StoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Project Schema
			Data *ProjectSchema `json:"data,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateResponse parses an HTTP response from a UpdateWithResponse call
func ParseUpdateResponse(rsp *http.Response) (*UpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Project Schema
			Data *ProjectSchema `json:"data,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListProjectsResponse parses an HTTP response from a ListProjectsWithResponse call
func ParseListProjectsResponse(rsp *http.Response) (*ListProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSnapshotResponse parses an HTTP response from a CreateSnapshotWithResponse call
func ParseCreateSnapshotResponse(rsp *http.Response) (*CreateSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRevertSnapshotResponse parses an HTTP response from a RevertSnapshotWithResponse call
func ParseRevertSnapshotResponse(rsp *http.Response) (*RevertSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevertSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDestroySnapshotResponse parses an HTTP response from a DestroySnapshotWithResponse call
func ParseDestroySnapshotResponse(rsp *http.Response) (*DestroySnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DestroySnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseShowSnapshotResponse parses an HTTP response from a ShowSnapshotWithResponse call
func ParseShowSnapshotResponse(rsp *http.Response) (*ShowSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SnapshotResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSnapshotResponse parses an HTTP response from a ListSnapshotWithResponse call
func ParseListSnapshotResponse(rsp *http.Response) (*ListSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SnapshotResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAclListResponse parses an HTTP response from a ListAclListWithResponse call
func ParseListAclListResponse(rsp *http.Response) (*ListAclListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAclListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VpcResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAclListResponse parses an HTTP response from a DeleteAclListWithResponse call
func ParseDeleteAclListResponse(rsp *http.Response) (*DeleteAclListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAclListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVpcStoreResponse parses an HTTP response from a VpcStoreWithResponse call
func ParseVpcStoreResponse(rsp *http.Response) (*VpcStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VpcStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Vpc Schema
			Data *VpcSchema `json:"data,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAclListResponse parses an HTTP response from a CreateAclListWithResponse call
func ParseCreateAclListResponse(rsp *http.Response) (*CreateAclListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAclListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAclResponse parses an HTTP response from a CreateAclWithResponse call
func ParseCreateAclResponse(rsp *http.Response) (*CreateAclResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAclResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAclListResponse parses an HTTP response from a UpdateAclListWithResponse call
func ParseUpdateAclListResponse(rsp *http.Response) (*UpdateAclListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAclListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDestroyResponse parses an HTTP response from a DestroyWithResponse call
func ParseDestroyResponse(rsp *http.Response) (*DestroyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DestroyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Batch Delete Vpc Schema
			Batch *DeleteVpcSchema `json:"batch,omitempty"`

			// Job Async Job Schema
			Job *AsyncJobSchema `json:"job,omitempty"`

			// Message Ok
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseShowResponse parses an HTTP response from a ShowWithResponse call
func ParseShowResponse(rsp *http.Response) (*ShowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VpcResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListResponse parses an HTTP response from a ListWithResponse call
func ParseListResponse(rsp *http.Response) (*ListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VpcResource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
